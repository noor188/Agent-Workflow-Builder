"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@mendable";
exports.ids = ["vendor-chunks/@mendable"];
exports.modules = {

/***/ "(ssr)/./node_modules/@mendable/firecrawl-js/dist/chunk-J3BEBX3Y.js":
/*!********************************************************************!*\
  !*** ./node_modules/@mendable/firecrawl-js/dist/chunk-J3BEBX3Y.js ***!
  \********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   require_package: () => (/* binding */ require_package)\n/* harmony export */ });\nvar __getOwnPropNames = Object.getOwnPropertyNames;\nvar __commonJS = (cb, mod) => function __require() {\n  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n};\n\n// package.json\nvar require_package = __commonJS({\n  \"package.json\"(exports, module) {\n    module.exports = {\n      name: \"@mendable/firecrawl-js\",\n      version: \"4.4.1\",\n      description: \"JavaScript SDK for Firecrawl API\",\n      main: \"dist/index.js\",\n      types: \"dist/index.d.ts\",\n      exports: {\n        \"./package.json\": \"./package.json\",\n        \".\": {\n          import: \"./dist/index.js\",\n          default: \"./dist/index.cjs\"\n        }\n      },\n      type: \"module\",\n      scripts: {\n        build: \"tsup\",\n        \"build-and-publish\": \"npm run build && npm publish --access public\",\n        \"publish-beta\": \"npm run build && npm publish --access public --tag beta\",\n        test: \"NODE_OPTIONS=--experimental-vm-modules jest --verbose src/__tests__/e2e/v2/*.test.ts --detectOpenHandles\",\n        \"test:unit\": \"NODE_OPTIONS=--experimental-vm-modules jest --verbose src/__tests__/unit/v2/*.test.ts\"\n      },\n      repository: {\n        type: \"git\",\n        url: \"git+https://github.com/firecrawl/firecrawl.git\"\n      },\n      author: \"Mendable.ai\",\n      license: \"MIT\",\n      dependencies: {\n        axios: \"^1.12.2\",\n        \"typescript-event-target\": \"^1.1.1\",\n        zod: \"^3.23.8\",\n        \"zod-to-json-schema\": \"^3.23.0\"\n      },\n      bugs: {\n        url: \"https://github.com/firecrawl/firecrawl/issues\"\n      },\n      homepage: \"https://github.com/firecrawl/firecrawl#readme\",\n      devDependencies: {\n        \"@jest/globals\": \"^30.0.5\",\n        \"@types/dotenv\": \"^8.2.0\",\n        \"@types/jest\": \"^30.0.0\",\n        \"@types/mocha\": \"^10.0.6\",\n        \"@types/node\": \"^20.12.12\",\n        \"@types/uuid\": \"^9.0.8\",\n        dotenv: \"^16.4.5\",\n        jest: \"^30.0.5\",\n        \"ts-jest\": \"^29.4.0\",\n        tsup: \"^8.5.0\",\n        typescript: \"^5.4.5\",\n        uuid: \"^9.0.1\"\n      },\n      keywords: [\n        \"firecrawl\",\n        \"mendable\",\n        \"crawler\",\n        \"web\",\n        \"scraper\",\n        \"api\",\n        \"sdk\"\n      ],\n      engines: {\n        node: \">=22.0.0\"\n      },\n      pnpm: {\n        overrides: {\n          \"@babel/helpers@<7.26.10\": \">=7.26.10\",\n          \"brace-expansion@>=1.0.0 <=1.1.11\": \">=1.1.12\",\n          \"brace-expansion@>=2.0.0 <=2.0.1\": \">=2.0.2\"\n        }\n      }\n    };\n  }\n});\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1lbmRhYmxlL2ZpcmVjcmF3bC1qcy9kaXN0L2NodW5rLUozQkVCWDNZLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTtBQUNBO0FBQ0EsMkRBQTJELGFBQWE7QUFDeEU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUlDIiwic291cmNlcyI6WyIvVXNlcnMvbm1hbWxvb2svRGVza3RvcC9TaWRlLVByb2plY3RzL0FnZW50LVdvcmtmbG93LUJ1aWxkZXItUHJvamVjdC9ub2RlX21vZHVsZXMvQG1lbmRhYmxlL2ZpcmVjcmF3bC1qcy9kaXN0L2NodW5rLUozQkVCWDNZLmpzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2dldE93blByb3BOYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzO1xudmFyIF9fY29tbW9uSlMgPSAoY2IsIG1vZCkgPT4gZnVuY3Rpb24gX19yZXF1aXJlKCkge1xuICByZXR1cm4gbW9kIHx8ICgwLCBjYltfX2dldE93blByb3BOYW1lcyhjYilbMF1dKSgobW9kID0geyBleHBvcnRzOiB7fSB9KS5leHBvcnRzLCBtb2QpLCBtb2QuZXhwb3J0cztcbn07XG5cbi8vIHBhY2thZ2UuanNvblxudmFyIHJlcXVpcmVfcGFja2FnZSA9IF9fY29tbW9uSlMoe1xuICBcInBhY2thZ2UuanNvblwiKGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIG1vZHVsZS5leHBvcnRzID0ge1xuICAgICAgbmFtZTogXCJAbWVuZGFibGUvZmlyZWNyYXdsLWpzXCIsXG4gICAgICB2ZXJzaW9uOiBcIjQuNC4xXCIsXG4gICAgICBkZXNjcmlwdGlvbjogXCJKYXZhU2NyaXB0IFNESyBmb3IgRmlyZWNyYXdsIEFQSVwiLFxuICAgICAgbWFpbjogXCJkaXN0L2luZGV4LmpzXCIsXG4gICAgICB0eXBlczogXCJkaXN0L2luZGV4LmQudHNcIixcbiAgICAgIGV4cG9ydHM6IHtcbiAgICAgICAgXCIuL3BhY2thZ2UuanNvblwiOiBcIi4vcGFja2FnZS5qc29uXCIsXG4gICAgICAgIFwiLlwiOiB7XG4gICAgICAgICAgaW1wb3J0OiBcIi4vZGlzdC9pbmRleC5qc1wiLFxuICAgICAgICAgIGRlZmF1bHQ6IFwiLi9kaXN0L2luZGV4LmNqc1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0eXBlOiBcIm1vZHVsZVwiLFxuICAgICAgc2NyaXB0czoge1xuICAgICAgICBidWlsZDogXCJ0c3VwXCIsXG4gICAgICAgIFwiYnVpbGQtYW5kLXB1Ymxpc2hcIjogXCJucG0gcnVuIGJ1aWxkICYmIG5wbSBwdWJsaXNoIC0tYWNjZXNzIHB1YmxpY1wiLFxuICAgICAgICBcInB1Ymxpc2gtYmV0YVwiOiBcIm5wbSBydW4gYnVpbGQgJiYgbnBtIHB1Ymxpc2ggLS1hY2Nlc3MgcHVibGljIC0tdGFnIGJldGFcIixcbiAgICAgICAgdGVzdDogXCJOT0RFX09QVElPTlM9LS1leHBlcmltZW50YWwtdm0tbW9kdWxlcyBqZXN0IC0tdmVyYm9zZSBzcmMvX190ZXN0c19fL2UyZS92Mi8qLnRlc3QudHMgLS1kZXRlY3RPcGVuSGFuZGxlc1wiLFxuICAgICAgICBcInRlc3Q6dW5pdFwiOiBcIk5PREVfT1BUSU9OUz0tLWV4cGVyaW1lbnRhbC12bS1tb2R1bGVzIGplc3QgLS12ZXJib3NlIHNyYy9fX3Rlc3RzX18vdW5pdC92Mi8qLnRlc3QudHNcIlxuICAgICAgfSxcbiAgICAgIHJlcG9zaXRvcnk6IHtcbiAgICAgICAgdHlwZTogXCJnaXRcIixcbiAgICAgICAgdXJsOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vZmlyZWNyYXdsL2ZpcmVjcmF3bC5naXRcIlxuICAgICAgfSxcbiAgICAgIGF1dGhvcjogXCJNZW5kYWJsZS5haVwiLFxuICAgICAgbGljZW5zZTogXCJNSVRcIixcbiAgICAgIGRlcGVuZGVuY2llczoge1xuICAgICAgICBheGlvczogXCJeMS4xMi4yXCIsXG4gICAgICAgIFwidHlwZXNjcmlwdC1ldmVudC10YXJnZXRcIjogXCJeMS4xLjFcIixcbiAgICAgICAgem9kOiBcIl4zLjIzLjhcIixcbiAgICAgICAgXCJ6b2QtdG8tanNvbi1zY2hlbWFcIjogXCJeMy4yMy4wXCJcbiAgICAgIH0sXG4gICAgICBidWdzOiB7XG4gICAgICAgIHVybDogXCJodHRwczovL2dpdGh1Yi5jb20vZmlyZWNyYXdsL2ZpcmVjcmF3bC9pc3N1ZXNcIlxuICAgICAgfSxcbiAgICAgIGhvbWVwYWdlOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9maXJlY3Jhd2wvZmlyZWNyYXdsI3JlYWRtZVwiLFxuICAgICAgZGV2RGVwZW5kZW5jaWVzOiB7XG4gICAgICAgIFwiQGplc3QvZ2xvYmFsc1wiOiBcIl4zMC4wLjVcIixcbiAgICAgICAgXCJAdHlwZXMvZG90ZW52XCI6IFwiXjguMi4wXCIsXG4gICAgICAgIFwiQHR5cGVzL2plc3RcIjogXCJeMzAuMC4wXCIsXG4gICAgICAgIFwiQHR5cGVzL21vY2hhXCI6IFwiXjEwLjAuNlwiLFxuICAgICAgICBcIkB0eXBlcy9ub2RlXCI6IFwiXjIwLjEyLjEyXCIsXG4gICAgICAgIFwiQHR5cGVzL3V1aWRcIjogXCJeOS4wLjhcIixcbiAgICAgICAgZG90ZW52OiBcIl4xNi40LjVcIixcbiAgICAgICAgamVzdDogXCJeMzAuMC41XCIsXG4gICAgICAgIFwidHMtamVzdFwiOiBcIl4yOS40LjBcIixcbiAgICAgICAgdHN1cDogXCJeOC41LjBcIixcbiAgICAgICAgdHlwZXNjcmlwdDogXCJeNS40LjVcIixcbiAgICAgICAgdXVpZDogXCJeOS4wLjFcIlxuICAgICAgfSxcbiAgICAgIGtleXdvcmRzOiBbXG4gICAgICAgIFwiZmlyZWNyYXdsXCIsXG4gICAgICAgIFwibWVuZGFibGVcIixcbiAgICAgICAgXCJjcmF3bGVyXCIsXG4gICAgICAgIFwid2ViXCIsXG4gICAgICAgIFwic2NyYXBlclwiLFxuICAgICAgICBcImFwaVwiLFxuICAgICAgICBcInNka1wiXG4gICAgICBdLFxuICAgICAgZW5naW5lczoge1xuICAgICAgICBub2RlOiBcIj49MjIuMC4wXCJcbiAgICAgIH0sXG4gICAgICBwbnBtOiB7XG4gICAgICAgIG92ZXJyaWRlczoge1xuICAgICAgICAgIFwiQGJhYmVsL2hlbHBlcnNAPDcuMjYuMTBcIjogXCI+PTcuMjYuMTBcIixcbiAgICAgICAgICBcImJyYWNlLWV4cGFuc2lvbkA+PTEuMC4wIDw9MS4xLjExXCI6IFwiPj0xLjEuMTJcIixcbiAgICAgICAgICBcImJyYWNlLWV4cGFuc2lvbkA+PTIuMC4wIDw9Mi4wLjFcIjogXCI+PTIuMC4yXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbn0pO1xuXG5leHBvcnQge1xuICByZXF1aXJlX3BhY2thZ2Vcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mendable/firecrawl-js/dist/chunk-J3BEBX3Y.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@mendable/firecrawl-js/dist/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@mendable/firecrawl-js/dist/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Firecrawl: () => (/* binding */ Firecrawl),\n/* harmony export */   FirecrawlAppV1: () => (/* binding */ FirecrawlApp),\n/* harmony export */   FirecrawlClient: () => (/* binding */ FirecrawlClient),\n/* harmony export */   SdkError: () => (/* binding */ SdkError),\n/* harmony export */   \"default\": () => (/* binding */ index_default)\n/* harmony export */ });\n/* harmony import */ var _chunk_J3BEBX3Y_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-J3BEBX3Y.js */ \"(ssr)/./node_modules/@mendable/firecrawl-js/dist/chunk-J3BEBX3Y.js\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/lib/axios.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod-to-json-schema */ \"(ssr)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n/* harmony import */ var events__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! events */ \"events\");\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! axios */ \"(ssr)/./node_modules/axios/index.js\");\n\n\n// src/v2/utils/httpClient.ts\n\n\n// src/v2/utils/getVersion.ts\nfunction getVersion() {\n  try {\n    if (typeof process !== \"undefined\" && process.env && process.env.npm_package_version) {\n      return process.env.npm_package_version;\n    }\n    const pkg = (0,_chunk_J3BEBX3Y_js__WEBPACK_IMPORTED_MODULE_0__.require_package)();\n    return pkg?.version || \"3.x.x\";\n  } catch {\n    return \"3.x.x\";\n  }\n}\n\n// src/v2/utils/httpClient.ts\nvar HttpClient = class {\n  instance;\n  apiKey;\n  apiUrl;\n  maxRetries;\n  backoffFactor;\n  constructor(options) {\n    this.apiKey = options.apiKey;\n    this.apiUrl = options.apiUrl.replace(/\\/$/, \"\");\n    this.maxRetries = options.maxRetries ?? 3;\n    this.backoffFactor = options.backoffFactor ?? 0.5;\n    this.instance = axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].create({\n      baseURL: this.apiUrl,\n      timeout: options.timeoutMs ?? 6e4,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${this.apiKey}`\n      },\n      transitional: { clarifyTimeoutError: true }\n    });\n  }\n  getApiUrl() {\n    return this.apiUrl;\n  }\n  getApiKey() {\n    return this.apiKey;\n  }\n  async request(config) {\n    const version = getVersion();\n    config.headers = {\n      ...config.headers || {}\n    };\n    let lastError;\n    for (let attempt = 0; attempt < this.maxRetries; attempt++) {\n      try {\n        const cfg = { ...config };\n        if (cfg.method && [\"post\", \"put\", \"patch\"].includes(cfg.method.toLowerCase())) {\n          const data = cfg.data ?? {};\n          cfg.data = { ...data, origin: typeof data.origin === \"string\" && data.origin.includes(\"mcp\") ? data.origin : `js-sdk@${version}` };\n          if (typeof data.timeout === \"number\") {\n            cfg.timeout = data.timeout + 5e3;\n          }\n        }\n        const res = await this.instance.request(cfg);\n        if (res.status === 502 && attempt < this.maxRetries - 1) {\n          await this.sleep(this.backoffFactor * Math.pow(2, attempt));\n          continue;\n        }\n        return res;\n      } catch (err) {\n        lastError = err;\n        const status = err?.response?.status;\n        if (status === 502 && attempt < this.maxRetries - 1) {\n          await this.sleep(this.backoffFactor * Math.pow(2, attempt));\n          continue;\n        }\n        throw err;\n      }\n    }\n    throw lastError ?? new Error(\"Unexpected HTTP client error\");\n  }\n  sleep(seconds) {\n    return new Promise((r) => setTimeout(r, seconds * 1e3));\n  }\n  post(endpoint, body, headers) {\n    return this.request({ method: \"post\", url: endpoint, data: body, headers });\n  }\n  get(endpoint, headers) {\n    return this.request({ method: \"get\", url: endpoint, headers });\n  }\n  delete(endpoint, headers) {\n    return this.request({ method: \"delete\", url: endpoint, headers });\n  }\n  prepareHeaders(idempotencyKey) {\n    const headers = {};\n    if (idempotencyKey) headers[\"x-idempotency-key\"] = idempotencyKey;\n    return headers;\n  }\n};\n\n// src/v2/types.ts\nvar SdkError = class extends Error {\n  status;\n  code;\n  details;\n  constructor(message, status, code, details) {\n    super(message);\n    this.name = \"FirecrawlSdkError\";\n    this.status = status;\n    this.code = code;\n    this.details = details;\n  }\n};\n\n// src/v2/utils/validation.ts\n\nfunction ensureValidFormats(formats) {\n  if (!formats) return;\n  for (const fmt of formats) {\n    if (typeof fmt === \"string\") {\n      if (fmt === \"json\") {\n        throw new Error(\"json format must be an object with { type: 'json', prompt, schema }\");\n      }\n      continue;\n    }\n    if (fmt.type === \"json\") {\n      const j = fmt;\n      if (!j.prompt && !j.schema) {\n        throw new Error(\"json format requires either 'prompt' or 'schema' (or both)\");\n      }\n      const maybeSchema = j.schema;\n      const isZod = !!maybeSchema && (typeof maybeSchema.safeParse === \"function\" || typeof maybeSchema.parse === \"function\") && !!maybeSchema._def;\n      if (isZod) {\n        try {\n          j.schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(maybeSchema);\n        } catch {\n        }\n      }\n      continue;\n    }\n    if (fmt.type === \"changeTracking\") {\n      const ct = fmt;\n      const maybeSchema = ct.schema;\n      const isZod = !!maybeSchema && (typeof maybeSchema.safeParse === \"function\" || typeof maybeSchema.parse === \"function\") && !!maybeSchema._def;\n      if (isZod) {\n        try {\n          ct.schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(maybeSchema);\n        } catch {\n        }\n      }\n      continue;\n    }\n    if (fmt.type === \"screenshot\") {\n      const s = fmt;\n      if (s.quality != null && (typeof s.quality !== \"number\" || s.quality < 0)) {\n        throw new Error(\"screenshot.quality must be a non-negative number\");\n      }\n    }\n  }\n}\nfunction ensureValidScrapeOptions(options) {\n  if (!options) return;\n  if (options.timeout != null && options.timeout <= 0) {\n    throw new Error(\"timeout must be positive\");\n  }\n  if (options.waitFor != null && options.waitFor < 0) {\n    throw new Error(\"waitFor must be non-negative\");\n  }\n  ensureValidFormats(options.formats);\n}\n\n// src/v2/utils/errorHandler.ts\n\nfunction throwForBadResponse(resp, action) {\n  const status = resp.status;\n  const body = resp.data || {};\n  const msg = body?.error || body?.message || `Request failed (${status}) while trying to ${action}`;\n  throw new SdkError(msg, status, void 0, body?.details);\n}\nfunction normalizeAxiosError(err, action) {\n  const status = err.response?.status;\n  const body = err.response?.data;\n  const message = body?.error || err.message || `Request failed${status ? ` (${status})` : \"\"} while trying to ${action}`;\n  const code = body?.code || err.code;\n  throw new SdkError(message, status, code, body?.details ?? body);\n}\n\n// src/v2/methods/scrape.ts\nasync function scrape(http, url, options) {\n  if (!url || !url.trim()) {\n    throw new Error(\"URL cannot be empty\");\n  }\n  if (options) ensureValidScrapeOptions(options);\n  const payload = { url: url.trim() };\n  if (options) Object.assign(payload, options);\n  try {\n    const res = await http.post(\"/v2/scrape\", payload);\n    if (res.status !== 200 || !res.data?.success) {\n      throwForBadResponse(res, \"scrape\");\n    }\n    return res.data.data || {};\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"scrape\");\n    throw err;\n  }\n}\n\n// src/v2/methods/search.ts\nfunction prepareSearchPayload(req) {\n  if (!req.query || !req.query.trim()) throw new Error(\"Query cannot be empty\");\n  if (req.limit != null && req.limit <= 0) throw new Error(\"limit must be positive\");\n  if (req.timeout != null && req.timeout <= 0) throw new Error(\"timeout must be positive\");\n  const payload = {\n    query: req.query\n  };\n  if (req.sources) payload.sources = req.sources;\n  if (req.categories) payload.categories = req.categories;\n  if (req.limit != null) payload.limit = req.limit;\n  if (req.tbs != null) payload.tbs = req.tbs;\n  if (req.location != null) payload.location = req.location;\n  if (req.ignoreInvalidURLs != null) payload.ignoreInvalidURLs = req.ignoreInvalidURLs;\n  if (req.timeout != null) payload.timeout = req.timeout;\n  if (req.integration && req.integration.trim()) payload.integration = req.integration.trim();\n  if (req.scrapeOptions) {\n    ensureValidScrapeOptions(req.scrapeOptions);\n    payload.scrapeOptions = req.scrapeOptions;\n  }\n  return payload;\n}\nfunction transformArray(arr) {\n  const results = [];\n  for (const item of arr) {\n    if (item && typeof item === \"object\") {\n      if (\"markdown\" in item || \"html\" in item || \"rawHtml\" in item || \"links\" in item || \"screenshot\" in item || \"changeTracking\" in item || \"summary\" in item || \"json\" in item) {\n        results.push(item);\n      } else {\n        results.push(item);\n      }\n    } else {\n      results.push({ url: item });\n    }\n  }\n  return results;\n}\nasync function search(http, request) {\n  const payload = prepareSearchPayload(request);\n  try {\n    const res = await http.post(\"/v2/search\", payload);\n    if (res.status !== 200 || !res.data?.success) {\n      throwForBadResponse(res, \"search\");\n    }\n    const data = res.data.data || {};\n    const out = {};\n    if (data.web) out.web = transformArray(data.web);\n    if (data.news) out.news = transformArray(data.news);\n    if (data.images) out.images = transformArray(data.images);\n    return out;\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"search\");\n    throw err;\n  }\n}\n\n// src/v2/methods/map.ts\nfunction prepareMapPayload(url, options) {\n  if (!url || !url.trim()) throw new Error(\"URL cannot be empty\");\n  const payload = { url: url.trim() };\n  if (options) {\n    if (options.sitemap != null) payload.sitemap = options.sitemap;\n    if (options.search != null) payload.search = options.search;\n    if (options.includeSubdomains != null) payload.includeSubdomains = options.includeSubdomains;\n    if (options.limit != null) payload.limit = options.limit;\n    if (options.timeout != null) payload.timeout = options.timeout;\n    if (options.integration != null && options.integration.trim()) payload.integration = options.integration.trim();\n    if (options.location != null) payload.location = options.location;\n  }\n  return payload;\n}\nasync function map(http, url, options) {\n  const payload = prepareMapPayload(url, options);\n  try {\n    const res = await http.post(\"/v2/map\", payload);\n    if (res.status !== 200 || !res.data?.success) {\n      throwForBadResponse(res, \"map\");\n    }\n    const linksIn = res.data.links || [];\n    const links = [];\n    for (const item of linksIn) {\n      if (typeof item === \"string\") links.push({ url: item });\n      else if (item && typeof item === \"object\") links.push({ url: item.url, title: item.title, description: item.description });\n    }\n    return { links };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"map\");\n    throw err;\n  }\n}\n\n// src/v2/utils/pagination.ts\nasync function fetchAllPages(http, nextUrl, initial, pagination) {\n  const docs = initial.slice();\n  let current = nextUrl;\n  let pageCount = 0;\n  const maxPages = pagination?.maxPages ?? void 0;\n  const maxResults = pagination?.maxResults ?? void 0;\n  const maxWaitTime = pagination?.maxWaitTime ?? void 0;\n  const started = Date.now();\n  while (current) {\n    if (maxPages != null && pageCount >= maxPages) break;\n    if (maxWaitTime != null && (Date.now() - started) / 1e3 > maxWaitTime) break;\n    let payload = null;\n    try {\n      const res = await http.get(current);\n      payload = res.data;\n    } catch {\n      break;\n    }\n    if (!payload?.success) break;\n    for (const d of payload.data || []) {\n      if (maxResults != null && docs.length >= maxResults) break;\n      docs.push(d);\n    }\n    if (maxResults != null && docs.length >= maxResults) break;\n    current = payload.next ?? null;\n    pageCount += 1;\n  }\n  return docs;\n}\n\n// src/v2/methods/crawl.ts\nfunction prepareCrawlPayload(request) {\n  if (!request.url || !request.url.trim()) throw new Error(\"URL cannot be empty\");\n  const data = { url: request.url.trim() };\n  if (request.prompt) data.prompt = request.prompt;\n  if (request.excludePaths) data.excludePaths = request.excludePaths;\n  if (request.includePaths) data.includePaths = request.includePaths;\n  if (request.maxDiscoveryDepth != null) data.maxDiscoveryDepth = request.maxDiscoveryDepth;\n  if (request.sitemap != null) data.sitemap = request.sitemap;\n  if (request.ignoreQueryParameters != null) data.ignoreQueryParameters = request.ignoreQueryParameters;\n  if (request.limit != null) data.limit = request.limit;\n  if (request.crawlEntireDomain != null) data.crawlEntireDomain = request.crawlEntireDomain;\n  if (request.allowExternalLinks != null) data.allowExternalLinks = request.allowExternalLinks;\n  if (request.allowSubdomains != null) data.allowSubdomains = request.allowSubdomains;\n  if (request.delay != null) data.delay = request.delay;\n  if (request.maxConcurrency != null) data.maxConcurrency = request.maxConcurrency;\n  if (request.webhook != null) data.webhook = request.webhook;\n  if (request.integration != null && request.integration.trim()) data.integration = request.integration.trim();\n  if (request.scrapeOptions) {\n    ensureValidScrapeOptions(request.scrapeOptions);\n    data.scrapeOptions = request.scrapeOptions;\n  }\n  if (request.zeroDataRetention != null) data.zeroDataRetention = request.zeroDataRetention;\n  return data;\n}\nasync function startCrawl(http, request) {\n  const payload = prepareCrawlPayload(request);\n  try {\n    const res = await http.post(\"/v2/crawl\", payload);\n    if (res.status !== 200 || !res.data?.success) {\n      throwForBadResponse(res, \"start crawl\");\n    }\n    return { id: res.data.id, url: res.data.url };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"start crawl\");\n    throw err;\n  }\n}\nasync function getCrawlStatus(http, jobId, pagination) {\n  try {\n    const res = await http.get(`/v2/crawl/${jobId}`);\n    if (res.status !== 200 || !res.data?.success) {\n      throwForBadResponse(res, \"get crawl status\");\n    }\n    const body = res.data;\n    const initialDocs = body.data || [];\n    const auto = pagination?.autoPaginate ?? true;\n    if (!auto || !body.next) {\n      return {\n        status: body.status,\n        completed: body.completed ?? 0,\n        total: body.total ?? 0,\n        creditsUsed: body.creditsUsed,\n        expiresAt: body.expiresAt,\n        next: body.next ?? null,\n        data: initialDocs\n      };\n    }\n    const aggregated = await fetchAllPages(http, body.next, initialDocs, pagination);\n    return {\n      status: body.status,\n      completed: body.completed ?? 0,\n      total: body.total ?? 0,\n      creditsUsed: body.creditsUsed,\n      expiresAt: body.expiresAt,\n      next: null,\n      data: aggregated\n    };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get crawl status\");\n    throw err;\n  }\n}\nasync function cancelCrawl(http, jobId) {\n  try {\n    const res = await http.delete(`/v2/crawl/${jobId}`);\n    if (res.status !== 200) throwForBadResponse(res, \"cancel crawl\");\n    return res.data?.status === \"cancelled\";\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"cancel crawl\");\n    throw err;\n  }\n}\nasync function waitForCrawlCompletion(http, jobId, pollInterval = 2, timeout) {\n  const start = Date.now();\n  while (true) {\n    const status = await getCrawlStatus(http, jobId);\n    if ([\"completed\", \"failed\", \"cancelled\"].includes(status.status)) return status;\n    if (timeout != null && Date.now() - start > timeout * 1e3) {\n      throw new Error(`Crawl job ${jobId} did not complete within ${timeout} seconds`);\n    }\n    await new Promise((r) => setTimeout(r, Math.max(1e3, pollInterval * 1e3)));\n  }\n}\nasync function crawl(http, request, pollInterval = 2, timeout) {\n  const started = await startCrawl(http, request);\n  return waitForCrawlCompletion(http, started.id, pollInterval, timeout);\n}\nasync function getCrawlErrors(http, crawlId) {\n  try {\n    const res = await http.get(`/v2/crawl/${crawlId}/errors`);\n    if (res.status !== 200) throwForBadResponse(res, \"get crawl errors\");\n    const payload = res.data?.data ?? res.data;\n    return { errors: payload.errors || [], robotsBlocked: payload.robotsBlocked || [] };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get crawl errors\");\n    throw err;\n  }\n}\nasync function getActiveCrawls(http) {\n  try {\n    const res = await http.get(`/v2/crawl/active`);\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"get active crawls\");\n    const crawlsIn = res.data?.crawls || [];\n    const crawls = crawlsIn.map((c) => ({ id: c.id, teamId: c.teamId ?? c.team_id, url: c.url, options: c.options ?? null }));\n    return { success: true, crawls };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get active crawls\");\n    throw err;\n  }\n}\nasync function crawlParamsPreview(http, url, prompt) {\n  if (!url || !url.trim()) throw new Error(\"URL cannot be empty\");\n  if (!prompt || !prompt.trim()) throw new Error(\"Prompt cannot be empty\");\n  try {\n    const res = await http.post(\"/v2/crawl/params-preview\", { url: url.trim(), prompt });\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"crawl params preview\");\n    const data = res.data.data || {};\n    if (res.data.warning) data.warning = res.data.warning;\n    return data;\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"crawl params preview\");\n    throw err;\n  }\n}\n\n// src/v2/methods/batch.ts\nasync function startBatchScrape(http, urls, {\n  options,\n  webhook,\n  appendToId,\n  ignoreInvalidURLs,\n  maxConcurrency,\n  zeroDataRetention,\n  idempotencyKey,\n  integration\n} = {}) {\n  if (!Array.isArray(urls) || urls.length === 0) throw new Error(\"URLs list cannot be empty\");\n  const payload = { urls };\n  if (options) {\n    ensureValidScrapeOptions(options);\n    Object.assign(payload, options);\n  }\n  if (webhook != null) payload.webhook = webhook;\n  if (appendToId != null) payload.appendToId = appendToId;\n  if (ignoreInvalidURLs != null) payload.ignoreInvalidURLs = ignoreInvalidURLs;\n  if (maxConcurrency != null) payload.maxConcurrency = maxConcurrency;\n  if (zeroDataRetention != null) payload.zeroDataRetention = zeroDataRetention;\n  if (integration != null && integration.trim()) payload.integration = integration.trim();\n  try {\n    const headers = http.prepareHeaders(idempotencyKey);\n    const res = await http.post(\"/v2/batch/scrape\", payload, headers);\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"start batch scrape\");\n    return { id: res.data.id, url: res.data.url, invalidURLs: res.data.invalidURLs || void 0 };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"start batch scrape\");\n    throw err;\n  }\n}\nasync function getBatchScrapeStatus(http, jobId, pagination) {\n  try {\n    const res = await http.get(`/v2/batch/scrape/${jobId}`);\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"get batch scrape status\");\n    const body = res.data;\n    const initialDocs = body.data || [];\n    const auto = pagination?.autoPaginate ?? true;\n    if (!auto || !body.next) {\n      return {\n        status: body.status,\n        completed: body.completed ?? 0,\n        total: body.total ?? 0,\n        creditsUsed: body.creditsUsed,\n        expiresAt: body.expiresAt,\n        next: body.next ?? null,\n        data: initialDocs\n      };\n    }\n    const aggregated = await fetchAllPages(http, body.next, initialDocs, pagination);\n    return {\n      status: body.status,\n      completed: body.completed ?? 0,\n      total: body.total ?? 0,\n      creditsUsed: body.creditsUsed,\n      expiresAt: body.expiresAt,\n      next: null,\n      data: aggregated\n    };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get batch scrape status\");\n    throw err;\n  }\n}\nasync function cancelBatchScrape(http, jobId) {\n  try {\n    const res = await http.delete(`/v2/batch/scrape/${jobId}`);\n    if (res.status !== 200) throwForBadResponse(res, \"cancel batch scrape\");\n    return res.data?.status === \"cancelled\";\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"cancel batch scrape\");\n    throw err;\n  }\n}\nasync function getBatchScrapeErrors(http, jobId) {\n  try {\n    const res = await http.get(`/v2/batch/scrape/${jobId}/errors`);\n    if (res.status !== 200) throwForBadResponse(res, \"get batch scrape errors\");\n    const payload = res.data?.data ?? res.data;\n    return { errors: payload.errors || [], robotsBlocked: payload.robotsBlocked || [] };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get batch scrape errors\");\n    throw err;\n  }\n}\nasync function waitForBatchCompletion(http, jobId, pollInterval = 2, timeout) {\n  const start = Date.now();\n  while (true) {\n    const status = await getBatchScrapeStatus(http, jobId);\n    if ([\"completed\", \"failed\", \"cancelled\"].includes(status.status)) return status;\n    if (timeout != null && Date.now() - start > timeout * 1e3) {\n      throw new Error(`Batch scrape job ${jobId} did not complete within ${timeout} seconds`);\n    }\n    await new Promise((r) => setTimeout(r, Math.max(1e3, pollInterval * 1e3)));\n  }\n}\nasync function batchScrape(http, urls, opts = {}) {\n  const start = await startBatchScrape(http, urls, opts);\n  return waitForBatchCompletion(http, start.id, opts.pollInterval ?? 2, opts.timeout);\n}\n\n// src/v2/methods/extract.ts\n\nfunction prepareExtractPayload(args) {\n  const body = {};\n  if (args.urls) body.urls = args.urls;\n  if (args.prompt != null) body.prompt = args.prompt;\n  if (args.schema != null) {\n    const s = args.schema;\n    const isZod = s && (typeof s.safeParse === \"function\" || typeof s.parse === \"function\") && s._def;\n    body.schema = isZod ? (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(s) : args.schema;\n  }\n  if (args.systemPrompt != null) body.systemPrompt = args.systemPrompt;\n  if (args.allowExternalLinks != null) body.allowExternalLinks = args.allowExternalLinks;\n  if (args.enableWebSearch != null) body.enableWebSearch = args.enableWebSearch;\n  if (args.showSources != null) body.showSources = args.showSources;\n  if (args.ignoreInvalidURLs != null) body.ignoreInvalidURLs = args.ignoreInvalidURLs;\n  if (args.integration && args.integration.trim()) body.integration = args.integration.trim();\n  if (args.agent) body.agent = args.agent;\n  if (args.scrapeOptions) {\n    ensureValidScrapeOptions(args.scrapeOptions);\n    body.scrapeOptions = args.scrapeOptions;\n  }\n  return body;\n}\nasync function startExtract(http, args) {\n  const payload = prepareExtractPayload(args);\n  try {\n    const res = await http.post(\"/v2/extract\", payload);\n    if (res.status !== 200) throwForBadResponse(res, \"extract\");\n    return res.data;\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"extract\");\n    throw err;\n  }\n}\nasync function getExtractStatus(http, jobId) {\n  try {\n    const res = await http.get(`/v2/extract/${jobId}`);\n    if (res.status !== 200) throwForBadResponse(res, \"extract status\");\n    return res.data;\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"extract status\");\n    throw err;\n  }\n}\nasync function waitExtract(http, jobId, pollInterval = 2, timeout) {\n  const start = Date.now();\n  while (true) {\n    const status = await getExtractStatus(http, jobId);\n    if ([\"completed\", \"failed\", \"cancelled\"].includes(status.status || \"\")) return status;\n    if (timeout != null && Date.now() - start > timeout * 1e3) return status;\n    await new Promise((r) => setTimeout(r, Math.max(1e3, pollInterval * 1e3)));\n  }\n}\nasync function extract(http, args) {\n  const started = await startExtract(http, args);\n  const jobId = started.id;\n  if (!jobId) return started;\n  return waitExtract(http, jobId, args.pollInterval ?? 2, args.timeout);\n}\n\n// src/v2/methods/usage.ts\nasync function getConcurrency(http) {\n  try {\n    const res = await http.get(\"/v2/concurrency-check\");\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"get concurrency\");\n    const d = res.data.data || res.data;\n    return { concurrency: d.concurrency, maxConcurrency: d.maxConcurrency ?? d.max_concurrency };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get concurrency\");\n    throw err;\n  }\n}\nasync function getCreditUsage(http) {\n  try {\n    const res = await http.get(\"/v2/team/credit-usage\");\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"get credit usage\");\n    const d = res.data.data || res.data;\n    return {\n      remainingCredits: d.remainingCredits ?? d.remaining_credits ?? 0,\n      planCredits: d.planCredits ?? d.plan_credits,\n      billingPeriodStart: d.billingPeriodStart ?? d.billing_period_start ?? null,\n      billingPeriodEnd: d.billingPeriodEnd ?? d.billing_period_end ?? null\n    };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get credit usage\");\n    throw err;\n  }\n}\nasync function getTokenUsage(http) {\n  try {\n    const res = await http.get(\"/v2/team/token-usage\");\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"get token usage\");\n    const d = res.data.data || res.data;\n    return {\n      remainingTokens: d.remainingTokens ?? d.remaining_tokens ?? 0,\n      planTokens: d.planTokens ?? d.plan_tokens,\n      billingPeriodStart: d.billingPeriodStart ?? d.billing_period_start ?? null,\n      billingPeriodEnd: d.billingPeriodEnd ?? d.billing_period_end ?? null\n    };\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get token usage\");\n    throw err;\n  }\n}\nasync function getQueueStatus(http) {\n  try {\n    const res = await http.get(\"/v2/team/queue-status\");\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"get queue status\");\n    return res.data;\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get queue status\");\n    throw err;\n  }\n}\nasync function getCreditUsageHistorical(http, byApiKey) {\n  try {\n    const query = byApiKey ? \"?byApiKey=true\" : \"\";\n    const res = await http.get(`/v2/team/credit-usage/historical${query}`);\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"get credit usage historical\");\n    return res.data;\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get credit usage historical\");\n    throw err;\n  }\n}\nasync function getTokenUsageHistorical(http, byApiKey) {\n  try {\n    const query = byApiKey ? \"?byApiKey=true\" : \"\";\n    const res = await http.get(`/v2/team/token-usage/historical${query}`);\n    if (res.status !== 200 || !res.data?.success) throwForBadResponse(res, \"get token usage historical\");\n    return res.data;\n  } catch (err) {\n    if (err?.isAxiosError) return normalizeAxiosError(err, \"get token usage historical\");\n    throw err;\n  }\n}\n\n// src/v2/watcher.ts\n\nvar Watcher = class extends events__WEBPACK_IMPORTED_MODULE_3__.EventEmitter {\n  http;\n  jobId;\n  kind;\n  pollInterval;\n  timeout;\n  ws;\n  closed = false;\n  constructor(http, jobId, opts = {}) {\n    super();\n    this.http = http;\n    this.jobId = jobId;\n    this.kind = opts.kind ?? \"crawl\";\n    this.pollInterval = opts.pollInterval ?? 2;\n    this.timeout = opts.timeout;\n  }\n  buildWsUrl() {\n    const apiUrl = this.http.getApiUrl();\n    const wsBase = apiUrl.replace(/^http/, \"ws\");\n    const path = this.kind === \"crawl\" ? `/v2/crawl/${this.jobId}` : `/v2/batch/scrape/${this.jobId}`;\n    return `${wsBase}${path}`;\n  }\n  async start() {\n    try {\n      const url = this.buildWsUrl();\n      this.ws = new WebSocket(url, this.http.getApiKey());\n      this.attachWsHandlers(this.ws);\n    } catch {\n      this.pollLoop();\n    }\n  }\n  attachWsHandlers(ws) {\n    let startTs = Date.now();\n    const timeoutMs = this.timeout ? this.timeout * 1e3 : void 0;\n    ws.onmessage = (ev) => {\n      try {\n        const body = typeof ev.data === \"string\" ? JSON.parse(ev.data) : null;\n        if (!body) return;\n        const type = body.type;\n        if (type === \"error\") {\n          this.emit(\"error\", { status: \"failed\", data: [], error: body.error, id: this.jobId });\n          return;\n        }\n        if (type === \"catchup\") {\n          const payload2 = body.data || {};\n          this.emitDocuments(payload2.data || []);\n          this.emitSnapshot(payload2);\n          return;\n        }\n        if (type === \"document\") {\n          const doc = body.data;\n          if (doc) this.emit(\"document\", doc);\n          return;\n        }\n        if (type === \"done\") {\n          this.emit(\"done\", { status: \"completed\", data: [], id: this.jobId });\n          this.close();\n          return;\n        }\n        const payload = body.data || body;\n        if (payload && payload.status) this.emitSnapshot(payload);\n      } catch {\n      }\n      if (timeoutMs && Date.now() - startTs > timeoutMs) this.close();\n    };\n    ws.onerror = () => {\n      this.emit(\"error\", { status: \"failed\", data: [], error: \"WebSocket error\", id: this.jobId });\n      this.close();\n    };\n    ws.onclose = () => {\n      if (!this.closed) this.pollLoop();\n    };\n  }\n  emitDocuments(docs) {\n    for (const doc of docs) this.emit(\"document\", { ...doc, id: this.jobId });\n  }\n  emitSnapshot(payload) {\n    const status = payload.status;\n    const data = payload.data || [];\n    const snap = this.kind === \"crawl\" ? {\n      status,\n      completed: payload.completed ?? 0,\n      total: payload.total ?? 0,\n      creditsUsed: payload.creditsUsed,\n      expiresAt: payload.expiresAt,\n      next: payload.next ?? null,\n      data\n    } : {\n      status,\n      completed: payload.completed ?? 0,\n      total: payload.total ?? 0,\n      creditsUsed: payload.creditsUsed,\n      expiresAt: payload.expiresAt,\n      next: payload.next ?? null,\n      data\n    };\n    this.emit(\"snapshot\", snap);\n    if ([\"completed\", \"failed\", \"cancelled\"].includes(status)) {\n      this.emit(\"done\", { status, data, id: this.jobId });\n      this.close();\n    }\n  }\n  async pollLoop() {\n    const startTs = Date.now();\n    const timeoutMs = this.timeout ? this.timeout * 1e3 : void 0;\n    while (!this.closed) {\n      try {\n        const snap = this.kind === \"crawl\" ? await getCrawlStatus(this.http, this.jobId) : await getBatchScrapeStatus(this.http, this.jobId);\n        this.emit(\"snapshot\", snap);\n        if ([\"completed\", \"failed\", \"cancelled\"].includes(snap.status)) {\n          this.emit(\"done\", { status: snap.status, data: snap.data, id: this.jobId });\n          this.close();\n          break;\n        }\n      } catch {\n      }\n      if (timeoutMs && Date.now() - startTs > timeoutMs) break;\n      await new Promise((r) => setTimeout(r, Math.max(1e3, this.pollInterval * 1e3)));\n    }\n  }\n  close() {\n    this.closed = true;\n    if (this.ws && this.ws.close) this.ws.close();\n  }\n};\n\n// src/v2/client.ts\n\nvar FirecrawlClient = class {\n  http;\n  isCloudService(url) {\n    return url.includes(\"api.firecrawl.dev\");\n  }\n  /**\n   * Create a v2 client.\n   * @param options Transport configuration (API key, base URL, timeouts, retries).\n   */\n  constructor(options = {}) {\n    const apiKey = options.apiKey ?? process.env.FIRECRAWL_API_KEY ?? \"\";\n    const apiUrl = (options.apiUrl ?? process.env.FIRECRAWL_API_URL ?? \"https://api.firecrawl.dev\").replace(/\\/$/, \"\");\n    if (this.isCloudService(apiUrl) && !apiKey) {\n      throw new Error(\"API key is required for the cloud API. Set FIRECRAWL_API_KEY env or pass apiKey.\");\n    }\n    this.http = new HttpClient({\n      apiKey,\n      apiUrl,\n      timeoutMs: options.timeoutMs,\n      maxRetries: options.maxRetries,\n      backoffFactor: options.backoffFactor\n    });\n  }\n  async scrape(url, options) {\n    return scrape(this.http, url, options);\n  }\n  // Search\n  /**\n   * Search the web and optionally scrape each result.\n   * @param query Search query string.\n   * @param req Additional search options (sources, limit, scrapeOptions, etc.).\n   * @returns Structured search results.\n   */\n  async search(query, req = {}) {\n    return search(this.http, { query, ...req });\n  }\n  // Map\n  /**\n   * Map a site to discover URLs (sitemap-aware).\n   * @param url Root URL to map.\n   * @param options Mapping options (sitemap mode, includeSubdomains, limit, timeout).\n   * @returns Discovered links.\n   */\n  async map(url, options) {\n    return map(this.http, url, options);\n  }\n  // Crawl\n  /**\n   * Start a crawl job (async).\n   * @param url Root URL to crawl.\n   * @param req Crawl configuration (paths, limits, scrapeOptions, webhook, etc.).\n   * @returns Job id and url.\n   */\n  async startCrawl(url, req = {}) {\n    return startCrawl(this.http, { url, ...req });\n  }\n  /**\n   * Get the status and partial data of a crawl job.\n   * @param jobId Crawl job id.\n   */\n  async getCrawlStatus(jobId, pagination) {\n    return getCrawlStatus(this.http, jobId, pagination);\n  }\n  /**\n   * Cancel a crawl job.\n   * @param jobId Crawl job id.\n   * @returns True if cancelled.\n   */\n  async cancelCrawl(jobId) {\n    return cancelCrawl(this.http, jobId);\n  }\n  /**\n   * Convenience waiter: start a crawl and poll until it finishes.\n   * @param url Root URL to crawl.\n   * @param req Crawl configuration plus waiter controls (pollInterval, timeout seconds).\n   * @returns Final job snapshot.\n   */\n  async crawl(url, req = {}) {\n    return crawl(this.http, { url, ...req }, req.pollInterval, req.timeout);\n  }\n  /**\n   * Retrieve crawl errors and robots.txt blocks.\n   * @param crawlId Crawl job id.\n   */\n  async getCrawlErrors(crawlId) {\n    return getCrawlErrors(this.http, crawlId);\n  }\n  /**\n   * List active crawls for the authenticated team.\n   */\n  async getActiveCrawls() {\n    return getActiveCrawls(this.http);\n  }\n  /**\n   * Preview normalized crawl parameters produced by a natural-language prompt.\n   * @param url Root URL.\n   * @param prompt Natural-language instruction.\n   */\n  async crawlParamsPreview(url, prompt) {\n    return crawlParamsPreview(this.http, url, prompt);\n  }\n  // Batch\n  /**\n   * Start a batch scrape job for multiple URLs (async).\n   * @param urls URLs to scrape.\n   * @param opts Batch options (scrape options, webhook, concurrency, idempotency key, etc.).\n   * @returns Job id and url.\n   */\n  async startBatchScrape(urls, opts) {\n    return startBatchScrape(this.http, urls, opts);\n  }\n  /**\n   * Get the status and partial data of a batch scrape job.\n   * @param jobId Batch job id.\n   */\n  async getBatchScrapeStatus(jobId, pagination) {\n    return getBatchScrapeStatus(this.http, jobId, pagination);\n  }\n  /**\n   * Retrieve batch scrape errors and robots.txt blocks.\n   * @param jobId Batch job id.\n   */\n  async getBatchScrapeErrors(jobId) {\n    return getBatchScrapeErrors(this.http, jobId);\n  }\n  /**\n   * Cancel a batch scrape job.\n   * @param jobId Batch job id.\n   * @returns True if cancelled.\n   */\n  async cancelBatchScrape(jobId) {\n    return cancelBatchScrape(this.http, jobId);\n  }\n  /**\n   * Convenience waiter: start a batch scrape and poll until it finishes.\n   * @param urls URLs to scrape.\n   * @param opts Batch options plus waiter controls (pollInterval, timeout seconds).\n   * @returns Final job snapshot.\n   */\n  async batchScrape(urls, opts) {\n    return batchScrape(this.http, urls, opts);\n  }\n  // Extract\n  /**\n   * Start an extract job (async).\n   * @param args Extraction request (urls, schema or prompt, flags).\n   * @returns Job id or processing state.\n   */\n  async startExtract(args) {\n    return startExtract(this.http, args);\n  }\n  /**\n   * Get extract job status/data.\n   * @param jobId Extract job id.\n   */\n  async getExtractStatus(jobId) {\n    return getExtractStatus(this.http, jobId);\n  }\n  /**\n   * Convenience waiter: start an extract and poll until it finishes.\n   * @param args Extraction request plus waiter controls (pollInterval, timeout seconds).\n   * @returns Final extract response.\n   */\n  async extract(args) {\n    return extract(this.http, args);\n  }\n  // Usage\n  /** Current concurrency usage. */\n  async getConcurrency() {\n    return getConcurrency(this.http);\n  }\n  /** Current credit usage. */\n  async getCreditUsage() {\n    return getCreditUsage(this.http);\n  }\n  /** Recent token usage. */\n  async getTokenUsage() {\n    return getTokenUsage(this.http);\n  }\n  /** Historical credit usage by month; set byApiKey to true to break down by API key. */\n  async getCreditUsageHistorical(byApiKey) {\n    return getCreditUsageHistorical(this.http, byApiKey);\n  }\n  /** Historical token usage by month; set byApiKey to true to break down by API key. */\n  async getTokenUsageHistorical(byApiKey) {\n    return getTokenUsageHistorical(this.http, byApiKey);\n  }\n  /** Metrics about the team's scrape queue. */\n  async getQueueStatus() {\n    return getQueueStatus(this.http);\n  }\n  // Watcher\n  /**\n   * Create a watcher for a crawl or batch job. Emits: `document`, `snapshot`, `done`, `error`.\n   * @param jobId Job id.\n   * @param opts Watcher options (kind, pollInterval, timeout seconds).\n   */\n  watcher(jobId, opts = {}) {\n    return new Watcher(this.http, jobId, opts);\n  }\n};\n\n// src/v1/index.ts\n\n\n\n\n// node_modules/typescript-event-target/dist/index.mjs\nvar e = class extends EventTarget {\n  dispatchTypedEvent(s, t) {\n    return super.dispatchEvent(t);\n  }\n};\n\n// src/v1/index.ts\nvar FirecrawlError = class extends Error {\n  statusCode;\n  details;\n  constructor(message, statusCode, details) {\n    super(message);\n    this.statusCode = statusCode;\n    this.details = details;\n  }\n};\nvar FirecrawlApp = class {\n  apiKey;\n  apiUrl;\n  version = \"1.25.1\";\n  isCloudService(url) {\n    return url.includes(\"api.firecrawl.dev\");\n  }\n  async getVersion() {\n    try {\n      if (typeof process !== \"undefined\" && process.env && process.env.npm_package_version) {\n        return process.env.npm_package_version;\n      }\n      const packageJson = await __webpack_require__.e(/*! import() */ \"vendor-chunks/@mendable\").then(__webpack_require__.bind(__webpack_require__, /*! ./package-SYKCM5JT.js */ \"(ssr)/./node_modules/@mendable/firecrawl-js/dist/package-SYKCM5JT.js\"));\n      return packageJson.default.version;\n    } catch (error) {\n      const isTest = typeof process !== \"undefined\" && (process.env.JEST_WORKER_ID != null || false);\n      if (!isTest) {\n        console.error(\"Error getting version:\", error);\n      }\n      return \"1.25.1\";\n    }\n  }\n  async init() {\n    this.version = await this.getVersion();\n  }\n  /**\n   * Initializes a new instance of the FirecrawlApp class.\n   * @param config - Configuration options for the FirecrawlApp instance.\n   */\n  constructor({ apiKey = null, apiUrl = null }) {\n    const baseUrl = apiUrl || \"https://api.firecrawl.dev\";\n    if (this.isCloudService(baseUrl) && typeof apiKey !== \"string\") {\n      throw new FirecrawlError(\"No API key provided\", 401);\n    }\n    this.apiKey = apiKey || \"\";\n    this.apiUrl = baseUrl;\n    this.init();\n  }\n  /**\n   * Scrapes a URL using the Firecrawl API.\n   * @param url - The URL to scrape.\n   * @param params - Additional parameters for the scrape request.\n   * @returns The response from the scrape operation.\n   */\n  async scrapeUrl(url, params) {\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.apiKey}`\n    };\n    let jsonData = { url, ...params, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` };\n    if (jsonData?.extract?.schema) {\n      let schema = jsonData.extract.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        extract: {\n          ...jsonData.extract,\n          schema\n        }\n      };\n    }\n    if (jsonData?.jsonOptions?.schema) {\n      let schema = jsonData.jsonOptions.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        jsonOptions: {\n          ...jsonData.jsonOptions,\n          schema\n        }\n      };\n    }\n    try {\n      const response = await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(\n        this.apiUrl + `/v1/scrape`,\n        jsonData,\n        { headers, timeout: params?.timeout !== void 0 ? params.timeout + 5e3 : void 0 }\n      );\n      if (response.status === 200) {\n        const responseData = response.data;\n        if (responseData.success) {\n          return {\n            success: true,\n            warning: responseData.warning,\n            error: responseData.error,\n            ...responseData.data\n          };\n        } else {\n          throw new FirecrawlError(`Failed to scrape URL. Error: ${responseData.error}`, response.status);\n        }\n      } else {\n        this.handleError(response, \"scrape URL\");\n      }\n    } catch (error) {\n      this.handleError(error.response, \"scrape URL\");\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Searches using the Firecrawl API and optionally scrapes the results.\n   * @param query - The search query string.\n   * @param params - Optional parameters for the search request.\n   * @returns The response from the search operation.\n   */\n  async search(query, params) {\n    const headers = {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.apiKey}`\n    };\n    let jsonData = {\n      query,\n      limit: params?.limit ?? 5,\n      tbs: params?.tbs,\n      filter: params?.filter,\n      lang: params?.lang ?? \"en\",\n      country: params?.country ?? \"us\",\n      location: params?.location,\n      origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}`,\n      timeout: params?.timeout ?? 6e4,\n      scrapeOptions: params?.scrapeOptions ?? { formats: [] }\n    };\n    if (jsonData?.scrapeOptions?.extract?.schema) {\n      let schema = jsonData.scrapeOptions.extract.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        scrapeOptions: {\n          ...jsonData.scrapeOptions,\n          extract: {\n            ...jsonData.scrapeOptions.extract,\n            schema\n          }\n        }\n      };\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/search`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        const responseData = response.data;\n        if (responseData.success) {\n          return {\n            success: true,\n            data: responseData.data,\n            warning: responseData.warning\n          };\n        } else {\n          throw new FirecrawlError(`Failed to search. Error: ${responseData.error}`, response.status);\n        }\n      } else {\n        this.handleError(response, \"search\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\", data: [] };\n  }\n  /**\n   * Initiates a crawl job for a URL using the Firecrawl API.\n   * @param url - The URL to crawl.\n   * @param params - Additional parameters for the crawl request.\n   * @param pollInterval - Time in seconds for job status checks.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns The response from the crawl operation.\n   */\n  async crawlUrl(url, params, pollInterval = 2, idempotencyKey) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { url, ...params, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/crawl`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        const id = response.data.id;\n        return this.monitorJobStatus(id, headers, pollInterval);\n      } else {\n        this.handleError(response, \"start crawl job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  async asyncCrawlUrl(url, params, idempotencyKey) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { url, ...params, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/crawl`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start crawl job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Checks the status of a crawl job using the Firecrawl API.\n   * @param id - The ID of the crawl operation.\n   * @param getAllData - Paginate through all the pages of documents, returning the full list of all documents. (default: `false`)\n   * @param nextURL - The `next` URL from the previous crawl status. Only required if you're not manually increasing `skip`. Only used when `getAllData = false`.\n   * @param skip - How many entries to skip to paginate. Only required if you're not providing `nextURL`. Only used when `getAllData = false`.\n   * @param limit - How many entries to return. Only used when `getAllData = false`.\n   * @returns The response containing the job status.\n   */\n  async checkCrawlStatus(id, getAllData = false, nextURL, skip, limit) {\n    if (!id) {\n      throw new FirecrawlError(\"No crawl ID provided\", 400);\n    }\n    const headers = this.prepareHeaders();\n    const targetURL = new URL(nextURL ?? `${this.apiUrl}/v1/crawl/${id}`);\n    if (skip !== void 0) {\n      targetURL.searchParams.set(\"skip\", skip.toString());\n    }\n    if (limit !== void 0) {\n      targetURL.searchParams.set(\"limit\", limit.toString());\n    }\n    try {\n      const response = await this.getRequest(\n        targetURL.href,\n        headers\n      );\n      if (response.status === 200) {\n        let allData = response.data.data;\n        if (getAllData && response.data.status === \"completed\") {\n          let statusData = response.data;\n          if (\"data\" in statusData) {\n            let data = statusData.data;\n            while (typeof statusData === \"object\" && \"next\" in statusData) {\n              if (data.length === 0) {\n                break;\n              }\n              statusData = (await this.getRequest(statusData.next, headers)).data;\n              data = data.concat(statusData.data);\n            }\n            allData = data;\n          }\n        }\n        let resp = {\n          success: response.data.success,\n          status: response.data.status,\n          total: response.data.total,\n          completed: response.data.completed,\n          creditsUsed: response.data.creditsUsed,\n          next: getAllData ? void 0 : response.data.next,\n          expiresAt: new Date(response.data.expiresAt),\n          data: allData\n        };\n        if (!response.data.success && response.data.error) {\n          resp = {\n            ...resp,\n            success: false,\n            error: response.data.error\n          };\n        }\n        if (response.data.next) {\n          resp.next = response.data.next;\n        }\n        return resp;\n      } else {\n        this.handleError(response, \"check crawl status\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Returns information about crawl errors.\n   * @param id - The ID of the crawl operation.\n   * @returns Information about crawl errors.\n   */\n  async checkCrawlErrors(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.deleteRequest(\n        `${this.apiUrl}/v1/crawl/${id}/errors`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"check crawl errors\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Cancels a crawl job using the Firecrawl API.\n   * @param id - The ID of the crawl operation.\n   * @returns The response from the cancel crawl operation.\n   */\n  async cancelCrawl(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.deleteRequest(\n        `${this.apiUrl}/v1/crawl/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"cancel crawl job\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates a crawl job and returns a CrawlWatcher to monitor the job via WebSocket.\n   * @param url - The URL to crawl.\n   * @param params - Additional parameters for the crawl request.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns A CrawlWatcher instance to monitor the crawl job.\n   */\n  async crawlUrlAndWatch(url, params, idempotencyKey) {\n    const crawl2 = await this.asyncCrawlUrl(url, params, idempotencyKey);\n    if (crawl2.success && crawl2.id) {\n      const id = crawl2.id;\n      return new CrawlWatcher(id, this);\n    }\n    throw new FirecrawlError(\"Crawl job failed to start\", 400);\n  }\n  /**\n   * Maps a URL using the Firecrawl API.\n   * @param url - The URL to map.\n   * @param params - Additional parameters for the map request.\n   * @returns The response from the map operation.\n   */\n  async mapUrl(url, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { url, ...params, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/map`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"map\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates a batch scrape job for multiple URLs using the Firecrawl API.\n   * @param url - The URLs to scrape.\n   * @param params - Additional parameters for the scrape request.\n   * @param pollInterval - Time in seconds for job status checks.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @param webhook - Optional webhook for the batch scrape.\n   * @param ignoreInvalidURLs - Optional flag to ignore invalid URLs.\n   * @returns The response from the crawl operation.\n   */\n  async batchScrapeUrls(urls, params, pollInterval = 2, idempotencyKey, webhook, ignoreInvalidURLs, maxConcurrency) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { urls, webhook, ignoreInvalidURLs, maxConcurrency, ...params, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` };\n    if (jsonData?.extract?.schema) {\n      let schema = jsonData.extract.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        extract: {\n          ...jsonData.extract,\n          schema\n        }\n      };\n    }\n    if (jsonData?.jsonOptions?.schema) {\n      let schema = jsonData.jsonOptions.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        jsonOptions: {\n          ...jsonData.jsonOptions,\n          schema\n        }\n      };\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/batch/scrape`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        const id = response.data.id;\n        return this.monitorJobStatus(id, headers, pollInterval);\n      } else {\n        this.handleError(response, \"start batch scrape job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  async asyncBatchScrapeUrls(urls, params, idempotencyKey, webhook, ignoreInvalidURLs) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { urls, webhook, ignoreInvalidURLs, ...params, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` };\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/batch/scrape`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start batch scrape job\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates a batch scrape job and returns a CrawlWatcher to monitor the job via WebSocket.\n   * @param urls - The URL to scrape.\n   * @param params - Additional parameters for the scrape request.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns A CrawlWatcher instance to monitor the crawl job.\n   */\n  async batchScrapeUrlsAndWatch(urls, params, idempotencyKey, webhook, ignoreInvalidURLs) {\n    const crawl2 = await this.asyncBatchScrapeUrls(urls, params, idempotencyKey, webhook, ignoreInvalidURLs);\n    if (crawl2.success && crawl2.id) {\n      const id = crawl2.id;\n      return new CrawlWatcher(id, this);\n    }\n    throw new FirecrawlError(\"Batch scrape job failed to start\", 400);\n  }\n  /**\n   * Checks the status of a batch scrape job using the Firecrawl API.\n   * @param id - The ID of the batch scrape operation.\n   * @param getAllData - Paginate through all the pages of documents, returning the full list of all documents. (default: `false`)\n   * @param nextURL - The `next` URL from the previous batch scrape status. Only required if you're not manually increasing `skip`. Only used when `getAllData = false`.\n   * @param skip - How many entries to skip to paginate. Only used when `getAllData = false`.\n   * @param limit - How many entries to return. Only used when `getAllData = false`.\n   * @returns The response containing the job status.\n   */\n  async checkBatchScrapeStatus(id, getAllData = false, nextURL, skip, limit) {\n    if (!id) {\n      throw new FirecrawlError(\"No batch scrape ID provided\", 400);\n    }\n    const headers = this.prepareHeaders();\n    const targetURL = new URL(nextURL ?? `${this.apiUrl}/v1/batch/scrape/${id}`);\n    if (skip !== void 0) {\n      targetURL.searchParams.set(\"skip\", skip.toString());\n    }\n    if (limit !== void 0) {\n      targetURL.searchParams.set(\"limit\", limit.toString());\n    }\n    try {\n      const response = await this.getRequest(\n        targetURL.href,\n        headers\n      );\n      if (response.status === 200) {\n        let allData = response.data.data;\n        if (getAllData && response.data.status === \"completed\") {\n          let statusData = response.data;\n          if (\"data\" in statusData) {\n            let data = statusData.data;\n            while (typeof statusData === \"object\" && \"next\" in statusData) {\n              if (data.length === 0) {\n                break;\n              }\n              statusData = (await this.getRequest(statusData.next, headers)).data;\n              data = data.concat(statusData.data);\n            }\n            allData = data;\n          }\n        }\n        let resp = {\n          success: response.data.success,\n          status: response.data.status,\n          total: response.data.total,\n          completed: response.data.completed,\n          creditsUsed: response.data.creditsUsed,\n          next: getAllData ? void 0 : response.data.next,\n          expiresAt: new Date(response.data.expiresAt),\n          data: allData\n        };\n        if (!response.data.success && response.data.error) {\n          resp = {\n            ...resp,\n            success: false,\n            error: response.data.error\n          };\n        }\n        if (response.data.next) {\n          resp.next = response.data.next;\n        }\n        return resp;\n      } else {\n        this.handleError(response, \"check batch scrape status\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Returns information about batch scrape errors.\n   * @param id - The ID of the batch scrape operation.\n   * @returns Information about batch scrape errors.\n   */\n  async checkBatchScrapeErrors(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.deleteRequest(\n        `${this.apiUrl}/v1/batch/scrape/${id}/errors`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"check batch scrape errors\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Extracts information from URLs using the Firecrawl API.\n   * Currently in Beta. Expect breaking changes on future minor versions.\n   * @param urls - The URLs to extract information from. Optional if using other methods for data extraction.\n   * @param params - Additional parameters for the extract request.\n   * @returns The response from the extract operation.\n   */\n  async extract(urls, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { urls, ...params };\n    let jsonSchema;\n    try {\n      if (!params?.schema) {\n        jsonSchema = void 0;\n      } else {\n        try {\n          jsonSchema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(params.schema);\n        } catch (_) {\n          jsonSchema = params.schema;\n        }\n      }\n    } catch (error) {\n      throw new FirecrawlError(\"Invalid schema. Schema must be either a valid Zod schema or JSON schema object.\", 400);\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/extract`,\n        { ...jsonData, schema: jsonSchema, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` },\n        headers\n      );\n      if (response.status === 200) {\n        const jobId = response.data.id;\n        let extractStatus;\n        do {\n          const statusResponse = await this.getRequest(\n            `${this.apiUrl}/v1/extract/${jobId}`,\n            headers\n          );\n          extractStatus = statusResponse.data;\n          if (extractStatus.status === \"completed\") {\n            if (extractStatus.success) {\n              return {\n                success: true,\n                data: extractStatus.data,\n                warning: extractStatus.warning,\n                error: extractStatus.error,\n                sources: extractStatus?.sources || void 0\n              };\n            } else {\n              throw new FirecrawlError(`Failed to extract data. Error: ${extractStatus.error}`, statusResponse.status);\n            }\n          } else if (extractStatus.status === \"failed\" || extractStatus.status === \"cancelled\") {\n            throw new FirecrawlError(`Extract job ${extractStatus.status}. Error: ${extractStatus.error}`, statusResponse.status);\n          }\n          await new Promise((resolve) => setTimeout(resolve, 1e3));\n        } while (extractStatus.status !== \"completed\");\n      } else {\n        this.handleError(response, \"extract\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Initiates an asynchronous extract job for a URL using the Firecrawl API.\n   * @param url - The URL to extract data from.\n   * @param params - Additional parameters for the extract request.\n   * @param idempotencyKey - Optional idempotency key for the request.\n   * @returns The response from the extract operation.\n   */\n  async asyncExtract(urls, params, idempotencyKey) {\n    const headers = this.prepareHeaders(idempotencyKey);\n    let jsonData = { urls, ...params };\n    let jsonSchema;\n    try {\n      if (!params?.schema) {\n        jsonSchema = void 0;\n      } else {\n        try {\n          jsonSchema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(params.schema);\n        } catch (_) {\n          jsonSchema = params.schema;\n        }\n      }\n    } catch (error) {\n      throw new FirecrawlError(\"Invalid schema. Schema must be either a valid Zod schema or JSON schema object.\", 400);\n    }\n    try {\n      const response = await this.postRequest(\n        this.apiUrl + `/v1/extract`,\n        { ...jsonData, schema: jsonSchema, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` },\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start extract job\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Retrieves the status of an extract job.\n   * @param jobId - The ID of the extract job.\n   * @returns The status of the extract job.\n   */\n  async getExtractStatus(jobId) {\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/extract/${jobId}`,\n        this.prepareHeaders()\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"get extract status\");\n      }\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500);\n    }\n  }\n  /**\n   * Prepares the headers for an API request.\n   * @param idempotencyKey - Optional key to ensure idempotency.\n   * @returns The prepared headers.\n   */\n  prepareHeaders(idempotencyKey) {\n    return {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${this.apiKey}`,\n      ...idempotencyKey ? { \"x-idempotency-key\": idempotencyKey } : {}\n    };\n  }\n  /**\n   * Sends a POST request to the specified URL.\n   * @param url - The URL to send the request to.\n   * @param data - The data to send in the request.\n   * @param headers - The headers for the request.\n   * @returns The response from the POST request.\n   */\n  postRequest(url, data, headers) {\n    return axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].post(url, data, { headers, timeout: data?.timeout ? data.timeout + 5e3 : void 0 });\n  }\n  /**\n   * Sends a GET request to the specified URL.\n   * @param url - The URL to send the request to.\n   * @param headers - The headers for the request.\n   * @returns The response from the GET request.\n   */\n  async getRequest(url, headers) {\n    try {\n      return await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].get(url, { headers });\n    } catch (error) {\n      if (error instanceof axios__WEBPACK_IMPORTED_MODULE_4__.AxiosError && error.response) {\n        return error.response;\n      } else {\n        throw error;\n      }\n    }\n  }\n  /**\n   * Sends a DELETE request to the specified URL.\n   * @param url - The URL to send the request to.\n   * @param headers - The headers for the request.\n   * @returns The response from the DELETE request.\n   */\n  async deleteRequest(url, headers) {\n    try {\n      return await axios__WEBPACK_IMPORTED_MODULE_1__[\"default\"].delete(url, { headers });\n    } catch (error) {\n      if (error instanceof axios__WEBPACK_IMPORTED_MODULE_4__.AxiosError && error.response) {\n        return error.response;\n      } else {\n        throw error;\n      }\n    }\n  }\n  /**\n   * Monitors the status of a crawl job until completion or failure.\n   * @param id - The ID of the crawl operation.\n   * @param headers - The headers for the request.\n   * @param checkInterval - Interval in seconds for job status checks.\n   * @param checkUrl - Optional URL to check the status (used for v1 API)\n   * @returns The final job status or data.\n   */\n  async monitorJobStatus(id, headers, checkInterval) {\n    let failedTries = 0;\n    let networkRetries = 0;\n    const maxNetworkRetries = 3;\n    while (true) {\n      try {\n        let statusResponse = await this.getRequest(\n          `${this.apiUrl}/v1/crawl/${id}`,\n          headers\n        );\n        if (statusResponse.status === 200) {\n          failedTries = 0;\n          networkRetries = 0;\n          let statusData = statusResponse.data;\n          if (statusData.status === \"completed\") {\n            if (\"data\" in statusData) {\n              let data = statusData.data;\n              while (typeof statusData === \"object\" && \"next\" in statusData) {\n                if (data.length === 0) {\n                  break;\n                }\n                statusResponse = await this.getRequest(statusData.next, headers);\n                statusData = statusResponse.data;\n                data = data.concat(statusData.data);\n              }\n              statusData.data = data;\n              return statusData;\n            } else {\n              throw new FirecrawlError(\"Crawl job completed but no data was returned\", 500);\n            }\n          } else if ([\"active\", \"paused\", \"pending\", \"queued\", \"waiting\", \"scraping\"].includes(statusData.status)) {\n            checkInterval = Math.max(checkInterval, 2);\n            await new Promise(\n              (resolve) => setTimeout(resolve, checkInterval * 1e3)\n            );\n          } else {\n            throw new FirecrawlError(\n              `Crawl job failed or was stopped. Status: ${statusData.status}`,\n              500\n            );\n          }\n        } else {\n          failedTries++;\n          if (failedTries >= 3) {\n            this.handleError(statusResponse, \"check crawl status\");\n          }\n        }\n      } catch (error) {\n        if (this.isRetryableError(error) && networkRetries < maxNetworkRetries) {\n          networkRetries++;\n          const backoffDelay = Math.min(1e3 * Math.pow(2, networkRetries - 1), 1e4);\n          await new Promise((resolve) => setTimeout(resolve, backoffDelay));\n          continue;\n        }\n        throw new FirecrawlError(error, 500);\n      }\n    }\n  }\n  /**\n   * Determines if an error is retryable (transient network error)\n   * @param error - The error to check\n   * @returns True if the error should be retried\n   */\n  isRetryableError(error) {\n    if (error instanceof axios__WEBPACK_IMPORTED_MODULE_4__.AxiosError) {\n      if (!error.response) {\n        const code = error.code;\n        const message = error.message?.toLowerCase() || \"\";\n        return code === \"ECONNRESET\" || code === \"ETIMEDOUT\" || code === \"ENOTFOUND\" || code === \"ECONNREFUSED\" || message.includes(\"socket hang up\") || message.includes(\"network error\") || message.includes(\"timeout\");\n      }\n      if (error.response?.status === 408 || error.response?.status === 504) {\n        return true;\n      }\n    }\n    if (error && typeof error === \"object\") {\n      const code = error.code;\n      const message = error.message?.toLowerCase() || \"\";\n      if (code === \"ECONNRESET\" || code === \"ETIMEDOUT\" || code === \"ENOTFOUND\" || code === \"ECONNREFUSED\" || message.includes(\"socket hang up\") || message.includes(\"network error\") || message.includes(\"timeout\")) {\n        return true;\n      }\n      if (error.response?.status === 408 || error.response?.status === 504) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Handles errors from API responses.\n   * @param {AxiosResponse} response - The response from the API.\n   * @param {string} action - The action being performed when the error occurred.\n   */\n  handleError(response, action) {\n    if (!response) {\n      throw new FirecrawlError(\n        `No response received while trying to ${action}. This may be a network error or the server is unreachable.`,\n        0\n      );\n    }\n    if ([400, 402, 403, 408, 409, 500].includes(response.status)) {\n      const errorMessage = response.data.error || \"Unknown error occurred\";\n      const details = response.data.details ? ` - ${JSON.stringify(response.data.details)}` : \"\";\n      throw new FirecrawlError(\n        `Failed to ${action}. Status code: ${response.status}. Error: ${errorMessage}${details}`,\n        response.status,\n        response?.data?.details\n      );\n    } else {\n      throw new FirecrawlError(\n        `Unexpected error occurred while trying to ${action}. Status code: ${response.status}`,\n        response.status\n      );\n    }\n  }\n  /**\n   * Initiates a deep research operation on a given query and polls until completion.\n   * @param query - The query to research.\n   * @param params - Parameters for the deep research operation.\n   * @param onActivity - Optional callback to receive activity updates in real-time.\n   * @param onSource - Optional callback to receive source updates in real-time.\n   * @returns The final research results.\n   */\n  async deepResearch(query, params, onActivity, onSource) {\n    try {\n      const response = await this.asyncDeepResearch(query, params);\n      if (!response.success || \"error\" in response) {\n        return { success: false, error: \"error\" in response ? response.error : \"Unknown error\" };\n      }\n      if (!response.id) {\n        throw new FirecrawlError(`Failed to start research. No job ID returned.`, 500);\n      }\n      const jobId = response.id;\n      let researchStatus;\n      let lastActivityCount = 0;\n      let lastSourceCount = 0;\n      while (true) {\n        researchStatus = await this.checkDeepResearchStatus(jobId);\n        if (\"error\" in researchStatus && !researchStatus.success) {\n          return researchStatus;\n        }\n        if (onActivity && researchStatus.activities) {\n          const newActivities = researchStatus.activities.slice(lastActivityCount);\n          for (const activity of newActivities) {\n            onActivity(activity);\n          }\n          lastActivityCount = researchStatus.activities.length;\n        }\n        if (onSource && researchStatus.sources) {\n          const newSources = researchStatus.sources.slice(lastSourceCount);\n          for (const source of newSources) {\n            onSource(source);\n          }\n          lastSourceCount = researchStatus.sources.length;\n        }\n        if (researchStatus.status === \"completed\") {\n          return researchStatus;\n        }\n        if (researchStatus.status === \"failed\") {\n          throw new FirecrawlError(\n            `Research job ${researchStatus.status}. Error: ${researchStatus.error}`,\n            500\n          );\n        }\n        if (researchStatus.status !== \"processing\") {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 2e3));\n      }\n      return { success: false, error: \"Research job terminated unexpectedly\" };\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n  }\n  /**\n   * Initiates a deep research operation on a given query without polling.\n   * @param params - Parameters for the deep research operation.\n   * @returns The response containing the research job ID.\n   */\n  async asyncDeepResearch(query, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { query, ...params, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` };\n    if (jsonData?.jsonOptions?.schema) {\n      let schema = jsonData.jsonOptions.schema;\n      try {\n        schema = (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__.zodToJsonSchema)(schema);\n      } catch (error) {\n      }\n      jsonData = {\n        ...jsonData,\n        jsonOptions: {\n          ...jsonData.jsonOptions,\n          schema\n        }\n      };\n    }\n    try {\n      const response = await this.postRequest(\n        `${this.apiUrl}/v1/deep-research`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start deep research\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Checks the status of a deep research operation.\n   * @param id - The ID of the deep research operation.\n   * @returns The current status and results of the research operation.\n   */\n  async checkDeepResearchStatus(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/deep-research/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else if (response.status === 404) {\n        throw new FirecrawlError(\"Deep research job not found\", 404);\n      } else {\n        this.handleError(response, \"check deep research status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * @deprecated Use deepResearch() instead\n   * Initiates a deep research operation on a given topic and polls until completion.\n   * @param topic - The topic to research.\n   * @param params - Parameters for the deep research operation.\n   * @param onActivity - Optional callback to receive activity updates in real-time.\n   * @returns The final research results.\n   */\n  async __deepResearch(topic, params, onActivity) {\n    try {\n      const response = await this.__asyncDeepResearch(topic, params);\n      if (!response.success || \"error\" in response) {\n        return { success: false, error: \"error\" in response ? response.error : \"Unknown error\" };\n      }\n      if (!response.id) {\n        throw new FirecrawlError(`Failed to start research. No job ID returned.`, 500);\n      }\n      const jobId = response.id;\n      let researchStatus;\n      let lastActivityCount = 0;\n      while (true) {\n        researchStatus = await this.__checkDeepResearchStatus(jobId);\n        if (\"error\" in researchStatus && !researchStatus.success) {\n          return researchStatus;\n        }\n        if (onActivity && researchStatus.activities) {\n          const newActivities = researchStatus.activities.slice(lastActivityCount);\n          for (const activity of newActivities) {\n            onActivity(activity);\n          }\n          lastActivityCount = researchStatus.activities.length;\n        }\n        if (researchStatus.status === \"completed\") {\n          return researchStatus;\n        }\n        if (researchStatus.status === \"failed\") {\n          throw new FirecrawlError(\n            `Research job ${researchStatus.status}. Error: ${researchStatus.error}`,\n            500\n          );\n        }\n        if (researchStatus.status !== \"processing\") {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 2e3));\n      }\n      return { success: false, error: \"Research job terminated unexpectedly\" };\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n  }\n  /**\n   * @deprecated Use asyncDeepResearch() instead\n   * Initiates a deep research operation on a given topic without polling.\n   * @param params - Parameters for the deep research operation.\n   * @returns The response containing the research job ID.\n   */\n  async __asyncDeepResearch(topic, params) {\n    const headers = this.prepareHeaders();\n    try {\n      let jsonData = { topic, ...params, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` };\n      const response = await this.postRequest(\n        `${this.apiUrl}/v1/deep-research`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start deep research\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * @deprecated Use checkDeepResearchStatus() instead\n   * Checks the status of a deep research operation.\n   * @param id - The ID of the deep research operation.\n   * @returns The current status and results of the research operation.\n   */\n  async __checkDeepResearchStatus(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/deep-research/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else if (response.status === 404) {\n        throw new FirecrawlError(\"Deep research job not found\", 404);\n      } else {\n        this.handleError(response, \"check deep research status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Generates LLMs.txt for a given URL and polls until completion.\n   * @param url - The URL to generate LLMs.txt from.\n   * @param params - Parameters for the LLMs.txt generation operation.\n   * @returns The final generation results.\n   */\n  async generateLLMsText(url, params) {\n    try {\n      const response = await this.asyncGenerateLLMsText(url, params);\n      if (!response.success || \"error\" in response) {\n        return { success: false, error: \"error\" in response ? response.error : \"Unknown error\" };\n      }\n      if (!response.id) {\n        throw new FirecrawlError(`Failed to start LLMs.txt generation. No job ID returned.`, 500);\n      }\n      const jobId = response.id;\n      let generationStatus;\n      while (true) {\n        generationStatus = await this.checkGenerateLLMsTextStatus(jobId);\n        if (\"error\" in generationStatus && !generationStatus.success) {\n          return generationStatus;\n        }\n        if (generationStatus.status === \"completed\") {\n          return generationStatus;\n        }\n        if (generationStatus.status === \"failed\") {\n          throw new FirecrawlError(\n            `LLMs.txt generation job ${generationStatus.status}. Error: ${generationStatus.error}`,\n            500\n          );\n        }\n        if (generationStatus.status !== \"processing\") {\n          break;\n        }\n        await new Promise((resolve) => setTimeout(resolve, 2e3));\n      }\n      return { success: false, error: \"LLMs.txt generation job terminated unexpectedly\" };\n    } catch (error) {\n      throw new FirecrawlError(error.message, 500, error.response?.data?.details);\n    }\n  }\n  /**\n   * Initiates a LLMs.txt generation operation without polling.\n   * @param url - The URL to generate LLMs.txt from.\n   * @param params - Parameters for the LLMs.txt generation operation.\n   * @returns The response containing the generation job ID.\n   */\n  async asyncGenerateLLMsText(url, params) {\n    const headers = this.prepareHeaders();\n    let jsonData = { url, ...params, origin: typeof params.origin === \"string\" && params.origin.includes(\"mcp\") ? params.origin : `js-sdk@${this.version}` };\n    try {\n      const response = await this.postRequest(\n        `${this.apiUrl}/v1/llmstxt`,\n        jsonData,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"start LLMs.txt generation\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Checks the status of a LLMs.txt generation operation.\n   * @param id - The ID of the LLMs.txt generation operation.\n   * @returns The current status and results of the generation operation.\n   */\n  async checkGenerateLLMsTextStatus(id) {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/llmstxt/${id}`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else if (response.status === 404) {\n        throw new FirecrawlError(\"LLMs.txt generation job not found\", 404);\n      } else {\n        this.handleError(response, \"check LLMs.txt generation status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Gets metrics about the team's scrape queue.\n   * @returns The current queue status.\n   */\n  async getQueueStatus() {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/team/queue-status`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"get queue status\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Gets current credit usage and billing period for the team (v1).\n   */\n  async getCreditUsage() {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/team/credit-usage`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"get credit usage\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Gets current token usage and billing period for the team (v1).\n   */\n  async getTokenUsage() {\n    const headers = this.prepareHeaders();\n    try {\n      const response = await this.getRequest(\n        `${this.apiUrl}/v1/team/token-usage`,\n        headers\n      );\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"get token usage\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Gets historical credit usage. Pass byApiKey=true to break down by API key.\n   */\n  async getCreditUsageHistorical(byApiKey) {\n    const headers = this.prepareHeaders();\n    try {\n      const url = `${this.apiUrl}/v1/team/credit-usage/historical${byApiKey ? \"?byApiKey=true\" : \"\"}`;\n      const response = await this.getRequest(url, headers);\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"get credit usage historical\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n  /**\n   * Gets historical token usage. Pass byApiKey=true to break down by API key.\n   */\n  async getTokenUsageHistorical(byApiKey) {\n    const headers = this.prepareHeaders();\n    try {\n      const url = `${this.apiUrl}/v1/team/token-usage/historical${byApiKey ? \"?byApiKey=true\" : \"\"}`;\n      const response = await this.getRequest(url, headers);\n      if (response.status === 200) {\n        return response.data;\n      } else {\n        this.handleError(response, \"get token usage historical\");\n      }\n    } catch (error) {\n      if (error.response?.data?.error) {\n        throw new FirecrawlError(`Request failed with status code ${error.response.status}. Error: ${error.response.data.error} ${error.response.data.details ? ` - ${JSON.stringify(error.response.data.details)}` : \"\"}`, error.response.status);\n      } else {\n        throw new FirecrawlError(error.message, 500);\n      }\n    }\n    return { success: false, error: \"Internal server error.\" };\n  }\n};\nvar CrawlWatcher = class extends e {\n  ws;\n  data;\n  status;\n  id;\n  constructor(id, app) {\n    super();\n    this.id = id;\n    const wsUrl = app.apiUrl.replace(/^http/, \"ws\");\n    this.ws = new WebSocket(`${wsUrl}/v1/crawl/${id}`, app.apiKey);\n    this.status = \"scraping\";\n    this.data = [];\n    const messageHandler = (msg) => {\n      if (msg.type === \"done\") {\n        this.status = \"completed\";\n        this.dispatchTypedEvent(\"done\", new CustomEvent(\"done\", {\n          detail: {\n            status: this.status,\n            data: this.data,\n            id: this.id\n          }\n        }));\n      } else if (msg.type === \"error\") {\n        this.status = \"failed\";\n        this.dispatchTypedEvent(\"error\", new CustomEvent(\"error\", {\n          detail: {\n            status: this.status,\n            data: this.data,\n            error: msg.error,\n            id: this.id\n          }\n        }));\n      } else if (msg.type === \"catchup\") {\n        this.status = msg.data.status;\n        this.data.push(...msg.data.data ?? []);\n        for (const doc of this.data) {\n          this.dispatchTypedEvent(\"document\", new CustomEvent(\"document\", {\n            detail: {\n              ...doc,\n              id: this.id\n            }\n          }));\n        }\n      } else if (msg.type === \"document\") {\n        this.dispatchTypedEvent(\"document\", new CustomEvent(\"document\", {\n          detail: {\n            ...msg.data,\n            id: this.id\n          }\n        }));\n      }\n    };\n    this.ws.onmessage = ((ev) => {\n      if (typeof ev.data !== \"string\") {\n        this.ws.close();\n        return;\n      }\n      try {\n        const msg = JSON.parse(ev.data);\n        messageHandler(msg);\n      } catch (error) {\n        console.error(\"Error on message\", error);\n      }\n    }).bind(this);\n    this.ws.onclose = ((ev) => {\n      try {\n        const msg = JSON.parse(ev.reason);\n        messageHandler(msg);\n      } catch (error) {\n        console.error(\"Error on close\", error);\n      }\n    }).bind(this);\n    this.ws.onerror = ((_) => {\n      this.status = \"failed\";\n      this.dispatchTypedEvent(\"error\", new CustomEvent(\"error\", {\n        detail: {\n          status: this.status,\n          data: this.data,\n          error: \"WebSocket error\",\n          id: this.id\n        }\n      }));\n    }).bind(this);\n  }\n  close() {\n    this.ws.close();\n  }\n};\n\n// src/index.ts\nvar Firecrawl = class extends FirecrawlClient {\n  /** Feature‑frozen v1 client (lazy). */\n  _v1;\n  _v1Opts;\n  /** @param opts API credentials and base URL. */\n  constructor(opts = {}) {\n    super(opts);\n    this._v1Opts = {\n      apiKey: opts.apiKey,\n      apiUrl: opts.apiUrl\n    };\n  }\n  /** Access the legacy v1 client (instantiated on first access). */\n  get v1() {\n    if (!this._v1) this._v1 = new FirecrawlApp(this._v1Opts);\n    return this._v1;\n  }\n};\nvar index_default = Firecrawl;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1lbmRhYmxlL2ZpcmVjcmF3bC1qcy9kaXN0L2luZGV4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFFNkI7O0FBRTdCO0FBQzBCOztBQUUxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsbUVBQWU7QUFDL0I7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiw2Q0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxZQUFZO0FBQzdDLE9BQU87QUFDUCxzQkFBc0I7QUFDdEIsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDJCQUEyQjtBQUNyRDtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsdUJBQXVCLDBHQUEwRyxRQUFRO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvREFBb0Q7QUFDOUU7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBLDBCQUEwQiwwQ0FBMEM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw4QkFBOEI7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLG1FQUFlO0FBQ3BDLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixtRUFBZTtBQUNyQyxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxPQUFPLG9CQUFvQixPQUFPO0FBQ25HO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsY0FBYyxPQUFPLFNBQVMsa0JBQWtCLE9BQU87QUFDeEg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxXQUFXO0FBQzVELDhEQUE4RCxpRUFBaUU7QUFDL0g7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLE1BQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxNQUFNO0FBQ3JEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsT0FBTywwQkFBMEIsU0FBUztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxpRkFBaUY7QUFDM0gsYUFBYTtBQUNiLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELHlCQUF5QjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsSUFBSTtBQUNOO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxNQUFNO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxNQUFNO0FBQzVEO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELE1BQU07QUFDekQ7QUFDQTtBQUNBLGFBQWE7QUFDYixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsT0FBTywwQkFBMEIsU0FBUztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUVBQWdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLE1BQU07QUFDcEQ7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLE1BQU07QUFDeEU7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxNQUFNO0FBQ3ZFO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDc0M7QUFDdEMsNEJBQTRCLGdEQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELFdBQVcsd0JBQXdCLFdBQVc7QUFDcEcsY0FBYyxPQUFPLEVBQUUsS0FBSztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLCtEQUErRDtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLCtDQUErQztBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLHNFQUFzRTtBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCx3QkFBd0I7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLHNEQUFzRDtBQUNwRjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsK0JBQStCLGVBQWU7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDLG1DQUFtQyxhQUFhO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCLDhCQUE4QixhQUFhO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDMkM7QUFDOUI7QUFDNEQ7O0FBRXpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFPRSIsInNvdXJjZXMiOlsiL1VzZXJzL25tYW1sb29rL0Rlc2t0b3AvU2lkZS1Qcm9qZWN0cy9BZ2VudC1Xb3JrZmxvdy1CdWlsZGVyLVByb2plY3Qvbm9kZV9tb2R1bGVzL0BtZW5kYWJsZS9maXJlY3Jhd2wtanMvZGlzdC9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICByZXF1aXJlX3BhY2thZ2Vcbn0gZnJvbSBcIi4vY2h1bmstSjNCRUJYM1kuanNcIjtcblxuLy8gc3JjL3YyL3V0aWxzL2h0dHBDbGllbnQudHNcbmltcG9ydCBheGlvcyBmcm9tIFwiYXhpb3NcIjtcblxuLy8gc3JjL3YyL3V0aWxzL2dldFZlcnNpb24udHNcbmZ1bmN0aW9uIGdldFZlcnNpb24oKSB7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiBwcm9jZXNzICE9PSBcInVuZGVmaW5lZFwiICYmIHByb2Nlc3MuZW52ICYmIHByb2Nlc3MuZW52Lm5wbV9wYWNrYWdlX3ZlcnNpb24pIHtcbiAgICAgIHJldHVybiBwcm9jZXNzLmVudi5ucG1fcGFja2FnZV92ZXJzaW9uO1xuICAgIH1cbiAgICBjb25zdCBwa2cgPSByZXF1aXJlX3BhY2thZ2UoKTtcbiAgICByZXR1cm4gcGtnPy52ZXJzaW9uIHx8IFwiMy54LnhcIjtcbiAgfSBjYXRjaCB7XG4gICAgcmV0dXJuIFwiMy54LnhcIjtcbiAgfVxufVxuXG4vLyBzcmMvdjIvdXRpbHMvaHR0cENsaWVudC50c1xudmFyIEh0dHBDbGllbnQgPSBjbGFzcyB7XG4gIGluc3RhbmNlO1xuICBhcGlLZXk7XG4gIGFwaVVybDtcbiAgbWF4UmV0cmllcztcbiAgYmFja29mZkZhY3RvcjtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMuYXBpS2V5ID0gb3B0aW9ucy5hcGlLZXk7XG4gICAgdGhpcy5hcGlVcmwgPSBvcHRpb25zLmFwaVVybC5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgdGhpcy5tYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzID8/IDM7XG4gICAgdGhpcy5iYWNrb2ZmRmFjdG9yID0gb3B0aW9ucy5iYWNrb2ZmRmFjdG9yID8/IDAuNTtcbiAgICB0aGlzLmluc3RhbmNlID0gYXhpb3MuY3JlYXRlKHtcbiAgICAgIGJhc2VVUkw6IHRoaXMuYXBpVXJsLFxuICAgICAgdGltZW91dDogb3B0aW9ucy50aW1lb3V0TXMgPz8gNmU0LFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpS2V5fWBcbiAgICAgIH0sXG4gICAgICB0cmFuc2l0aW9uYWw6IHsgY2xhcmlmeVRpbWVvdXRFcnJvcjogdHJ1ZSB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0QXBpVXJsKCkge1xuICAgIHJldHVybiB0aGlzLmFwaVVybDtcbiAgfVxuICBnZXRBcGlLZXkoKSB7XG4gICAgcmV0dXJuIHRoaXMuYXBpS2V5O1xuICB9XG4gIGFzeW5jIHJlcXVlc3QoY29uZmlnKSB7XG4gICAgY29uc3QgdmVyc2lvbiA9IGdldFZlcnNpb24oKTtcbiAgICBjb25maWcuaGVhZGVycyA9IHtcbiAgICAgIC4uLmNvbmZpZy5oZWFkZXJzIHx8IHt9XG4gICAgfTtcbiAgICBsZXQgbGFzdEVycm9yO1xuICAgIGZvciAobGV0IGF0dGVtcHQgPSAwOyBhdHRlbXB0IDwgdGhpcy5tYXhSZXRyaWVzOyBhdHRlbXB0KyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNmZyA9IHsgLi4uY29uZmlnIH07XG4gICAgICAgIGlmIChjZmcubWV0aG9kICYmIFtcInBvc3RcIiwgXCJwdXRcIiwgXCJwYXRjaFwiXS5pbmNsdWRlcyhjZmcubWV0aG9kLnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgY29uc3QgZGF0YSA9IGNmZy5kYXRhID8/IHt9O1xuICAgICAgICAgIGNmZy5kYXRhID0geyAuLi5kYXRhLCBvcmlnaW46IHR5cGVvZiBkYXRhLm9yaWdpbiA9PT0gXCJzdHJpbmdcIiAmJiBkYXRhLm9yaWdpbi5pbmNsdWRlcyhcIm1jcFwiKSA/IGRhdGEub3JpZ2luIDogYGpzLXNka0Ake3ZlcnNpb259YCB9O1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YS50aW1lb3V0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBjZmcudGltZW91dCA9IGRhdGEudGltZW91dCArIDVlMztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5pbnN0YW5jZS5yZXF1ZXN0KGNmZyk7XG4gICAgICAgIGlmIChyZXMuc3RhdHVzID09PSA1MDIgJiYgYXR0ZW1wdCA8IHRoaXMubWF4UmV0cmllcyAtIDEpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNsZWVwKHRoaXMuYmFja29mZkZhY3RvciAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gZXJyPy5yZXNwb25zZT8uc3RhdHVzO1xuICAgICAgICBpZiAoc3RhdHVzID09PSA1MDIgJiYgYXR0ZW1wdCA8IHRoaXMubWF4UmV0cmllcyAtIDEpIHtcbiAgICAgICAgICBhd2FpdCB0aGlzLnNsZWVwKHRoaXMuYmFja29mZkZhY3RvciAqIE1hdGgucG93KDIsIGF0dGVtcHQpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGxhc3RFcnJvciA/PyBuZXcgRXJyb3IoXCJVbmV4cGVjdGVkIEhUVFAgY2xpZW50IGVycm9yXCIpO1xuICB9XG4gIHNsZWVwKHNlY29uZHMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgc2Vjb25kcyAqIDFlMykpO1xuICB9XG4gIHBvc3QoZW5kcG9pbnQsIGJvZHksIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiBcInBvc3RcIiwgdXJsOiBlbmRwb2ludCwgZGF0YTogYm9keSwgaGVhZGVycyB9KTtcbiAgfVxuICBnZXQoZW5kcG9pbnQsIGhlYWRlcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KHsgbWV0aG9kOiBcImdldFwiLCB1cmw6IGVuZHBvaW50LCBoZWFkZXJzIH0pO1xuICB9XG4gIGRlbGV0ZShlbmRwb2ludCwgaGVhZGVycykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QoeyBtZXRob2Q6IFwiZGVsZXRlXCIsIHVybDogZW5kcG9pbnQsIGhlYWRlcnMgfSk7XG4gIH1cbiAgcHJlcGFyZUhlYWRlcnMoaWRlbXBvdGVuY3lLZXkpIHtcbiAgICBjb25zdCBoZWFkZXJzID0ge307XG4gICAgaWYgKGlkZW1wb3RlbmN5S2V5KSBoZWFkZXJzW1wieC1pZGVtcG90ZW5jeS1rZXlcIl0gPSBpZGVtcG90ZW5jeUtleTtcbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxufTtcblxuLy8gc3JjL3YyL3R5cGVzLnRzXG52YXIgU2RrRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgc3RhdHVzO1xuICBjb2RlO1xuICBkZXRhaWxzO1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLm5hbWUgPSBcIkZpcmVjcmF3bFNka0Vycm9yXCI7XG4gICAgdGhpcy5zdGF0dXMgPSBzdGF0dXM7XG4gICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59O1xuXG4vLyBzcmMvdjIvdXRpbHMvdmFsaWRhdGlvbi50c1xuaW1wb3J0IHsgem9kVG9Kc29uU2NoZW1hIH0gZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuZnVuY3Rpb24gZW5zdXJlVmFsaWRGb3JtYXRzKGZvcm1hdHMpIHtcbiAgaWYgKCFmb3JtYXRzKSByZXR1cm47XG4gIGZvciAoY29uc3QgZm10IG9mIGZvcm1hdHMpIHtcbiAgICBpZiAodHlwZW9mIGZtdCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKGZtdCA9PT0gXCJqc29uXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwianNvbiBmb3JtYXQgbXVzdCBiZSBhbiBvYmplY3Qgd2l0aCB7IHR5cGU6ICdqc29uJywgcHJvbXB0LCBzY2hlbWEgfVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoZm10LnR5cGUgPT09IFwianNvblwiKSB7XG4gICAgICBjb25zdCBqID0gZm10O1xuICAgICAgaWYgKCFqLnByb21wdCAmJiAhai5zY2hlbWEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwianNvbiBmb3JtYXQgcmVxdWlyZXMgZWl0aGVyICdwcm9tcHQnIG9yICdzY2hlbWEnIChvciBib3RoKVwiKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1heWJlU2NoZW1hID0gai5zY2hlbWE7XG4gICAgICBjb25zdCBpc1pvZCA9ICEhbWF5YmVTY2hlbWEgJiYgKHR5cGVvZiBtYXliZVNjaGVtYS5zYWZlUGFyc2UgPT09IFwiZnVuY3Rpb25cIiB8fCB0eXBlb2YgbWF5YmVTY2hlbWEucGFyc2UgPT09IFwiZnVuY3Rpb25cIikgJiYgISFtYXliZVNjaGVtYS5fZGVmO1xuICAgICAgaWYgKGlzWm9kKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgai5zY2hlbWEgPSB6b2RUb0pzb25TY2hlbWEobWF5YmVTY2hlbWEpO1xuICAgICAgICB9IGNhdGNoIHtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChmbXQudHlwZSA9PT0gXCJjaGFuZ2VUcmFja2luZ1wiKSB7XG4gICAgICBjb25zdCBjdCA9IGZtdDtcbiAgICAgIGNvbnN0IG1heWJlU2NoZW1hID0gY3Quc2NoZW1hO1xuICAgICAgY29uc3QgaXNab2QgPSAhIW1heWJlU2NoZW1hICYmICh0eXBlb2YgbWF5YmVTY2hlbWEuc2FmZVBhcnNlID09PSBcImZ1bmN0aW9uXCIgfHwgdHlwZW9mIG1heWJlU2NoZW1hLnBhcnNlID09PSBcImZ1bmN0aW9uXCIpICYmICEhbWF5YmVTY2hlbWEuX2RlZjtcbiAgICAgIGlmIChpc1pvZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGN0LnNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYShtYXliZVNjaGVtYSk7XG4gICAgICAgIH0gY2F0Y2gge1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGZtdC50eXBlID09PSBcInNjcmVlbnNob3RcIikge1xuICAgICAgY29uc3QgcyA9IGZtdDtcbiAgICAgIGlmIChzLnF1YWxpdHkgIT0gbnVsbCAmJiAodHlwZW9mIHMucXVhbGl0eSAhPT0gXCJudW1iZXJcIiB8fCBzLnF1YWxpdHkgPCAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzY3JlZW5zaG90LnF1YWxpdHkgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXJcIik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBlbnN1cmVWYWxpZFNjcmFwZU9wdGlvbnMob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpIHJldHVybjtcbiAgaWYgKG9wdGlvbnMudGltZW91dCAhPSBudWxsICYmIG9wdGlvbnMudGltZW91dCA8PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidGltZW91dCBtdXN0IGJlIHBvc2l0aXZlXCIpO1xuICB9XG4gIGlmIChvcHRpb25zLndhaXRGb3IgIT0gbnVsbCAmJiBvcHRpb25zLndhaXRGb3IgPCAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwid2FpdEZvciBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTtcbiAgfVxuICBlbnN1cmVWYWxpZEZvcm1hdHMob3B0aW9ucy5mb3JtYXRzKTtcbn1cblxuLy8gc3JjL3YyL3V0aWxzL2Vycm9ySGFuZGxlci50c1xuaW1wb3J0IFwiYXhpb3NcIjtcbmZ1bmN0aW9uIHRocm93Rm9yQmFkUmVzcG9uc2UocmVzcCwgYWN0aW9uKSB7XG4gIGNvbnN0IHN0YXR1cyA9IHJlc3Auc3RhdHVzO1xuICBjb25zdCBib2R5ID0gcmVzcC5kYXRhIHx8IHt9O1xuICBjb25zdCBtc2cgPSBib2R5Py5lcnJvciB8fCBib2R5Py5tZXNzYWdlIHx8IGBSZXF1ZXN0IGZhaWxlZCAoJHtzdGF0dXN9KSB3aGlsZSB0cnlpbmcgdG8gJHthY3Rpb259YDtcbiAgdGhyb3cgbmV3IFNka0Vycm9yKG1zZywgc3RhdHVzLCB2b2lkIDAsIGJvZHk/LmRldGFpbHMpO1xufVxuZnVuY3Rpb24gbm9ybWFsaXplQXhpb3NFcnJvcihlcnIsIGFjdGlvbikge1xuICBjb25zdCBzdGF0dXMgPSBlcnIucmVzcG9uc2U/LnN0YXR1cztcbiAgY29uc3QgYm9keSA9IGVyci5yZXNwb25zZT8uZGF0YTtcbiAgY29uc3QgbWVzc2FnZSA9IGJvZHk/LmVycm9yIHx8IGVyci5tZXNzYWdlIHx8IGBSZXF1ZXN0IGZhaWxlZCR7c3RhdHVzID8gYCAoJHtzdGF0dXN9KWAgOiBcIlwifSB3aGlsZSB0cnlpbmcgdG8gJHthY3Rpb259YDtcbiAgY29uc3QgY29kZSA9IGJvZHk/LmNvZGUgfHwgZXJyLmNvZGU7XG4gIHRocm93IG5ldyBTZGtFcnJvcihtZXNzYWdlLCBzdGF0dXMsIGNvZGUsIGJvZHk/LmRldGFpbHMgPz8gYm9keSk7XG59XG5cbi8vIHNyYy92Mi9tZXRob2RzL3NjcmFwZS50c1xuYXN5bmMgZnVuY3Rpb24gc2NyYXBlKGh0dHAsIHVybCwgb3B0aW9ucykge1xuICBpZiAoIXVybCB8fCAhdXJsLnRyaW0oKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVSTCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gIH1cbiAgaWYgKG9wdGlvbnMpIGVuc3VyZVZhbGlkU2NyYXBlT3B0aW9ucyhvcHRpb25zKTtcbiAgY29uc3QgcGF5bG9hZCA9IHsgdXJsOiB1cmwudHJpbSgpIH07XG4gIGlmIChvcHRpb25zKSBPYmplY3QuYXNzaWduKHBheWxvYWQsIG9wdGlvbnMpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAucG9zdChcIi92Mi9zY3JhcGVcIiwgcGF5bG9hZCk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCB8fCAhcmVzLmRhdGE/LnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93Rm9yQmFkUmVzcG9uc2UocmVzLCBcInNjcmFwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5kYXRhLmRhdGEgfHwge307XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnI/LmlzQXhpb3NFcnJvcikgcmV0dXJuIG5vcm1hbGl6ZUF4aW9zRXJyb3IoZXJyLCBcInNjcmFwZVwiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLy8gc3JjL3YyL21ldGhvZHMvc2VhcmNoLnRzXG5mdW5jdGlvbiBwcmVwYXJlU2VhcmNoUGF5bG9hZChyZXEpIHtcbiAgaWYgKCFyZXEucXVlcnkgfHwgIXJlcS5xdWVyeS50cmltKCkpIHRocm93IG5ldyBFcnJvcihcIlF1ZXJ5IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgaWYgKHJlcS5saW1pdCAhPSBudWxsICYmIHJlcS5saW1pdCA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJsaW1pdCBtdXN0IGJlIHBvc2l0aXZlXCIpO1xuICBpZiAocmVxLnRpbWVvdXQgIT0gbnVsbCAmJiByZXEudGltZW91dCA8PSAwKSB0aHJvdyBuZXcgRXJyb3IoXCJ0aW1lb3V0IG11c3QgYmUgcG9zaXRpdmVcIik7XG4gIGNvbnN0IHBheWxvYWQgPSB7XG4gICAgcXVlcnk6IHJlcS5xdWVyeVxuICB9O1xuICBpZiAocmVxLnNvdXJjZXMpIHBheWxvYWQuc291cmNlcyA9IHJlcS5zb3VyY2VzO1xuICBpZiAocmVxLmNhdGVnb3JpZXMpIHBheWxvYWQuY2F0ZWdvcmllcyA9IHJlcS5jYXRlZ29yaWVzO1xuICBpZiAocmVxLmxpbWl0ICE9IG51bGwpIHBheWxvYWQubGltaXQgPSByZXEubGltaXQ7XG4gIGlmIChyZXEudGJzICE9IG51bGwpIHBheWxvYWQudGJzID0gcmVxLnRicztcbiAgaWYgKHJlcS5sb2NhdGlvbiAhPSBudWxsKSBwYXlsb2FkLmxvY2F0aW9uID0gcmVxLmxvY2F0aW9uO1xuICBpZiAocmVxLmlnbm9yZUludmFsaWRVUkxzICE9IG51bGwpIHBheWxvYWQuaWdub3JlSW52YWxpZFVSTHMgPSByZXEuaWdub3JlSW52YWxpZFVSTHM7XG4gIGlmIChyZXEudGltZW91dCAhPSBudWxsKSBwYXlsb2FkLnRpbWVvdXQgPSByZXEudGltZW91dDtcbiAgaWYgKHJlcS5pbnRlZ3JhdGlvbiAmJiByZXEuaW50ZWdyYXRpb24udHJpbSgpKSBwYXlsb2FkLmludGVncmF0aW9uID0gcmVxLmludGVncmF0aW9uLnRyaW0oKTtcbiAgaWYgKHJlcS5zY3JhcGVPcHRpb25zKSB7XG4gICAgZW5zdXJlVmFsaWRTY3JhcGVPcHRpb25zKHJlcS5zY3JhcGVPcHRpb25zKTtcbiAgICBwYXlsb2FkLnNjcmFwZU9wdGlvbnMgPSByZXEuc2NyYXBlT3B0aW9ucztcbiAgfVxuICByZXR1cm4gcGF5bG9hZDtcbn1cbmZ1bmN0aW9uIHRyYW5zZm9ybUFycmF5KGFycikge1xuICBjb25zdCByZXN1bHRzID0gW107XG4gIGZvciAoY29uc3QgaXRlbSBvZiBhcnIpIHtcbiAgICBpZiAoaXRlbSAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgaWYgKFwibWFya2Rvd25cIiBpbiBpdGVtIHx8IFwiaHRtbFwiIGluIGl0ZW0gfHwgXCJyYXdIdG1sXCIgaW4gaXRlbSB8fCBcImxpbmtzXCIgaW4gaXRlbSB8fCBcInNjcmVlbnNob3RcIiBpbiBpdGVtIHx8IFwiY2hhbmdlVHJhY2tpbmdcIiBpbiBpdGVtIHx8IFwic3VtbWFyeVwiIGluIGl0ZW0gfHwgXCJqc29uXCIgaW4gaXRlbSkge1xuICAgICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRzLnB1c2goaXRlbSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdHMucHVzaCh7IHVybDogaXRlbSB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdHM7XG59XG5hc3luYyBmdW5jdGlvbiBzZWFyY2goaHR0cCwgcmVxdWVzdCkge1xuICBjb25zdCBwYXlsb2FkID0gcHJlcGFyZVNlYXJjaFBheWxvYWQocmVxdWVzdCk7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaHR0cC5wb3N0KFwiL3YyL3NlYXJjaFwiLCBwYXlsb2FkKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXMuZGF0YT8uc3VjY2Vzcykge1xuICAgICAgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwic2VhcmNoXCIpO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gcmVzLmRhdGEuZGF0YSB8fCB7fTtcbiAgICBjb25zdCBvdXQgPSB7fTtcbiAgICBpZiAoZGF0YS53ZWIpIG91dC53ZWIgPSB0cmFuc2Zvcm1BcnJheShkYXRhLndlYik7XG4gICAgaWYgKGRhdGEubmV3cykgb3V0Lm5ld3MgPSB0cmFuc2Zvcm1BcnJheShkYXRhLm5ld3MpO1xuICAgIGlmIChkYXRhLmltYWdlcykgb3V0LmltYWdlcyA9IHRyYW5zZm9ybUFycmF5KGRhdGEuaW1hZ2VzKTtcbiAgICByZXR1cm4gb3V0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyPy5pc0F4aW9zRXJyb3IpIHJldHVybiBub3JtYWxpemVBeGlvc0Vycm9yKGVyciwgXCJzZWFyY2hcIik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5cbi8vIHNyYy92Mi9tZXRob2RzL21hcC50c1xuZnVuY3Rpb24gcHJlcGFyZU1hcFBheWxvYWQodXJsLCBvcHRpb25zKSB7XG4gIGlmICghdXJsIHx8ICF1cmwudHJpbSgpKSB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICBjb25zdCBwYXlsb2FkID0geyB1cmw6IHVybC50cmltKCkgfTtcbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5zaXRlbWFwICE9IG51bGwpIHBheWxvYWQuc2l0ZW1hcCA9IG9wdGlvbnMuc2l0ZW1hcDtcbiAgICBpZiAob3B0aW9ucy5zZWFyY2ggIT0gbnVsbCkgcGF5bG9hZC5zZWFyY2ggPSBvcHRpb25zLnNlYXJjaDtcbiAgICBpZiAob3B0aW9ucy5pbmNsdWRlU3ViZG9tYWlucyAhPSBudWxsKSBwYXlsb2FkLmluY2x1ZGVTdWJkb21haW5zID0gb3B0aW9ucy5pbmNsdWRlU3ViZG9tYWlucztcbiAgICBpZiAob3B0aW9ucy5saW1pdCAhPSBudWxsKSBwYXlsb2FkLmxpbWl0ID0gb3B0aW9ucy5saW1pdDtcbiAgICBpZiAob3B0aW9ucy50aW1lb3V0ICE9IG51bGwpIHBheWxvYWQudGltZW91dCA9IG9wdGlvbnMudGltZW91dDtcbiAgICBpZiAob3B0aW9ucy5pbnRlZ3JhdGlvbiAhPSBudWxsICYmIG9wdGlvbnMuaW50ZWdyYXRpb24udHJpbSgpKSBwYXlsb2FkLmludGVncmF0aW9uID0gb3B0aW9ucy5pbnRlZ3JhdGlvbi50cmltKCk7XG4gICAgaWYgKG9wdGlvbnMubG9jYXRpb24gIT0gbnVsbCkgcGF5bG9hZC5sb2NhdGlvbiA9IG9wdGlvbnMubG9jYXRpb247XG4gIH1cbiAgcmV0dXJuIHBheWxvYWQ7XG59XG5hc3luYyBmdW5jdGlvbiBtYXAoaHR0cCwgdXJsLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBheWxvYWQgPSBwcmVwYXJlTWFwUGF5bG9hZCh1cmwsIG9wdGlvbnMpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAucG9zdChcIi92Mi9tYXBcIiwgcGF5bG9hZCk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCB8fCAhcmVzLmRhdGE/LnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93Rm9yQmFkUmVzcG9uc2UocmVzLCBcIm1hcFwiKTtcbiAgICB9XG4gICAgY29uc3QgbGlua3NJbiA9IHJlcy5kYXRhLmxpbmtzIHx8IFtdO1xuICAgIGNvbnN0IGxpbmtzID0gW107XG4gICAgZm9yIChjb25zdCBpdGVtIG9mIGxpbmtzSW4pIHtcbiAgICAgIGlmICh0eXBlb2YgaXRlbSA9PT0gXCJzdHJpbmdcIikgbGlua3MucHVzaCh7IHVybDogaXRlbSB9KTtcbiAgICAgIGVsc2UgaWYgKGl0ZW0gJiYgdHlwZW9mIGl0ZW0gPT09IFwib2JqZWN0XCIpIGxpbmtzLnB1c2goeyB1cmw6IGl0ZW0udXJsLCB0aXRsZTogaXRlbS50aXRsZSwgZGVzY3JpcHRpb246IGl0ZW0uZGVzY3JpcHRpb24gfSk7XG4gICAgfVxuICAgIHJldHVybiB7IGxpbmtzIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnI/LmlzQXhpb3NFcnJvcikgcmV0dXJuIG5vcm1hbGl6ZUF4aW9zRXJyb3IoZXJyLCBcIm1hcFwiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLy8gc3JjL3YyL3V0aWxzL3BhZ2luYXRpb24udHNcbmFzeW5jIGZ1bmN0aW9uIGZldGNoQWxsUGFnZXMoaHR0cCwgbmV4dFVybCwgaW5pdGlhbCwgcGFnaW5hdGlvbikge1xuICBjb25zdCBkb2NzID0gaW5pdGlhbC5zbGljZSgpO1xuICBsZXQgY3VycmVudCA9IG5leHRVcmw7XG4gIGxldCBwYWdlQ291bnQgPSAwO1xuICBjb25zdCBtYXhQYWdlcyA9IHBhZ2luYXRpb24/Lm1heFBhZ2VzID8/IHZvaWQgMDtcbiAgY29uc3QgbWF4UmVzdWx0cyA9IHBhZ2luYXRpb24/Lm1heFJlc3VsdHMgPz8gdm9pZCAwO1xuICBjb25zdCBtYXhXYWl0VGltZSA9IHBhZ2luYXRpb24/Lm1heFdhaXRUaW1lID8/IHZvaWQgMDtcbiAgY29uc3Qgc3RhcnRlZCA9IERhdGUubm93KCk7XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgaWYgKG1heFBhZ2VzICE9IG51bGwgJiYgcGFnZUNvdW50ID49IG1heFBhZ2VzKSBicmVhaztcbiAgICBpZiAobWF4V2FpdFRpbWUgIT0gbnVsbCAmJiAoRGF0ZS5ub3coKSAtIHN0YXJ0ZWQpIC8gMWUzID4gbWF4V2FpdFRpbWUpIGJyZWFrO1xuICAgIGxldCBwYXlsb2FkID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gYXdhaXQgaHR0cC5nZXQoY3VycmVudCk7XG4gICAgICBwYXlsb2FkID0gcmVzLmRhdGE7XG4gICAgfSBjYXRjaCB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFwYXlsb2FkPy5zdWNjZXNzKSBicmVhaztcbiAgICBmb3IgKGNvbnN0IGQgb2YgcGF5bG9hZC5kYXRhIHx8IFtdKSB7XG4gICAgICBpZiAobWF4UmVzdWx0cyAhPSBudWxsICYmIGRvY3MubGVuZ3RoID49IG1heFJlc3VsdHMpIGJyZWFrO1xuICAgICAgZG9jcy5wdXNoKGQpO1xuICAgIH1cbiAgICBpZiAobWF4UmVzdWx0cyAhPSBudWxsICYmIGRvY3MubGVuZ3RoID49IG1heFJlc3VsdHMpIGJyZWFrO1xuICAgIGN1cnJlbnQgPSBwYXlsb2FkLm5leHQgPz8gbnVsbDtcbiAgICBwYWdlQ291bnQgKz0gMTtcbiAgfVxuICByZXR1cm4gZG9jcztcbn1cblxuLy8gc3JjL3YyL21ldGhvZHMvY3Jhd2wudHNcbmZ1bmN0aW9uIHByZXBhcmVDcmF3bFBheWxvYWQocmVxdWVzdCkge1xuICBpZiAoIXJlcXVlc3QudXJsIHx8ICFyZXF1ZXN0LnVybC50cmltKCkpIHRocm93IG5ldyBFcnJvcihcIlVSTCBjYW5ub3QgYmUgZW1wdHlcIik7XG4gIGNvbnN0IGRhdGEgPSB7IHVybDogcmVxdWVzdC51cmwudHJpbSgpIH07XG4gIGlmIChyZXF1ZXN0LnByb21wdCkgZGF0YS5wcm9tcHQgPSByZXF1ZXN0LnByb21wdDtcbiAgaWYgKHJlcXVlc3QuZXhjbHVkZVBhdGhzKSBkYXRhLmV4Y2x1ZGVQYXRocyA9IHJlcXVlc3QuZXhjbHVkZVBhdGhzO1xuICBpZiAocmVxdWVzdC5pbmNsdWRlUGF0aHMpIGRhdGEuaW5jbHVkZVBhdGhzID0gcmVxdWVzdC5pbmNsdWRlUGF0aHM7XG4gIGlmIChyZXF1ZXN0Lm1heERpc2NvdmVyeURlcHRoICE9IG51bGwpIGRhdGEubWF4RGlzY292ZXJ5RGVwdGggPSByZXF1ZXN0Lm1heERpc2NvdmVyeURlcHRoO1xuICBpZiAocmVxdWVzdC5zaXRlbWFwICE9IG51bGwpIGRhdGEuc2l0ZW1hcCA9IHJlcXVlc3Quc2l0ZW1hcDtcbiAgaWYgKHJlcXVlc3QuaWdub3JlUXVlcnlQYXJhbWV0ZXJzICE9IG51bGwpIGRhdGEuaWdub3JlUXVlcnlQYXJhbWV0ZXJzID0gcmVxdWVzdC5pZ25vcmVRdWVyeVBhcmFtZXRlcnM7XG4gIGlmIChyZXF1ZXN0LmxpbWl0ICE9IG51bGwpIGRhdGEubGltaXQgPSByZXF1ZXN0LmxpbWl0O1xuICBpZiAocmVxdWVzdC5jcmF3bEVudGlyZURvbWFpbiAhPSBudWxsKSBkYXRhLmNyYXdsRW50aXJlRG9tYWluID0gcmVxdWVzdC5jcmF3bEVudGlyZURvbWFpbjtcbiAgaWYgKHJlcXVlc3QuYWxsb3dFeHRlcm5hbExpbmtzICE9IG51bGwpIGRhdGEuYWxsb3dFeHRlcm5hbExpbmtzID0gcmVxdWVzdC5hbGxvd0V4dGVybmFsTGlua3M7XG4gIGlmIChyZXF1ZXN0LmFsbG93U3ViZG9tYWlucyAhPSBudWxsKSBkYXRhLmFsbG93U3ViZG9tYWlucyA9IHJlcXVlc3QuYWxsb3dTdWJkb21haW5zO1xuICBpZiAocmVxdWVzdC5kZWxheSAhPSBudWxsKSBkYXRhLmRlbGF5ID0gcmVxdWVzdC5kZWxheTtcbiAgaWYgKHJlcXVlc3QubWF4Q29uY3VycmVuY3kgIT0gbnVsbCkgZGF0YS5tYXhDb25jdXJyZW5jeSA9IHJlcXVlc3QubWF4Q29uY3VycmVuY3k7XG4gIGlmIChyZXF1ZXN0LndlYmhvb2sgIT0gbnVsbCkgZGF0YS53ZWJob29rID0gcmVxdWVzdC53ZWJob29rO1xuICBpZiAocmVxdWVzdC5pbnRlZ3JhdGlvbiAhPSBudWxsICYmIHJlcXVlc3QuaW50ZWdyYXRpb24udHJpbSgpKSBkYXRhLmludGVncmF0aW9uID0gcmVxdWVzdC5pbnRlZ3JhdGlvbi50cmltKCk7XG4gIGlmIChyZXF1ZXN0LnNjcmFwZU9wdGlvbnMpIHtcbiAgICBlbnN1cmVWYWxpZFNjcmFwZU9wdGlvbnMocmVxdWVzdC5zY3JhcGVPcHRpb25zKTtcbiAgICBkYXRhLnNjcmFwZU9wdGlvbnMgPSByZXF1ZXN0LnNjcmFwZU9wdGlvbnM7XG4gIH1cbiAgaWYgKHJlcXVlc3QuemVyb0RhdGFSZXRlbnRpb24gIT0gbnVsbCkgZGF0YS56ZXJvRGF0YVJldGVudGlvbiA9IHJlcXVlc3QuemVyb0RhdGFSZXRlbnRpb247XG4gIHJldHVybiBkYXRhO1xufVxuYXN5bmMgZnVuY3Rpb24gc3RhcnRDcmF3bChodHRwLCByZXF1ZXN0KSB7XG4gIGNvbnN0IHBheWxvYWQgPSBwcmVwYXJlQ3Jhd2xQYXlsb2FkKHJlcXVlc3QpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAucG9zdChcIi92Mi9jcmF3bFwiLCBwYXlsb2FkKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXMuZGF0YT8uc3VjY2Vzcykge1xuICAgICAgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwic3RhcnQgY3Jhd2xcIik7XG4gICAgfVxuICAgIHJldHVybiB7IGlkOiByZXMuZGF0YS5pZCwgdXJsOiByZXMuZGF0YS51cmwgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVycj8uaXNBeGlvc0Vycm9yKSByZXR1cm4gbm9ybWFsaXplQXhpb3NFcnJvcihlcnIsIFwic3RhcnQgY3Jhd2xcIik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRDcmF3bFN0YXR1cyhodHRwLCBqb2JJZCwgcGFnaW5hdGlvbikge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAuZ2V0KGAvdjIvY3Jhd2wvJHtqb2JJZH1gKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXMuZGF0YT8uc3VjY2Vzcykge1xuICAgICAgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwiZ2V0IGNyYXdsIHN0YXR1c1wiKTtcbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHJlcy5kYXRhO1xuICAgIGNvbnN0IGluaXRpYWxEb2NzID0gYm9keS5kYXRhIHx8IFtdO1xuICAgIGNvbnN0IGF1dG8gPSBwYWdpbmF0aW9uPy5hdXRvUGFnaW5hdGUgPz8gdHJ1ZTtcbiAgICBpZiAoIWF1dG8gfHwgIWJvZHkubmV4dCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3RhdHVzOiBib2R5LnN0YXR1cyxcbiAgICAgICAgY29tcGxldGVkOiBib2R5LmNvbXBsZXRlZCA/PyAwLFxuICAgICAgICB0b3RhbDogYm9keS50b3RhbCA/PyAwLFxuICAgICAgICBjcmVkaXRzVXNlZDogYm9keS5jcmVkaXRzVXNlZCxcbiAgICAgICAgZXhwaXJlc0F0OiBib2R5LmV4cGlyZXNBdCxcbiAgICAgICAgbmV4dDogYm9keS5uZXh0ID8/IG51bGwsXG4gICAgICAgIGRhdGE6IGluaXRpYWxEb2NzXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBhZ2dyZWdhdGVkID0gYXdhaXQgZmV0Y2hBbGxQYWdlcyhodHRwLCBib2R5Lm5leHQsIGluaXRpYWxEb2NzLCBwYWdpbmF0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgc3RhdHVzOiBib2R5LnN0YXR1cyxcbiAgICAgIGNvbXBsZXRlZDogYm9keS5jb21wbGV0ZWQgPz8gMCxcbiAgICAgIHRvdGFsOiBib2R5LnRvdGFsID8/IDAsXG4gICAgICBjcmVkaXRzVXNlZDogYm9keS5jcmVkaXRzVXNlZCxcbiAgICAgIGV4cGlyZXNBdDogYm9keS5leHBpcmVzQXQsXG4gICAgICBuZXh0OiBudWxsLFxuICAgICAgZGF0YTogYWdncmVnYXRlZFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnI/LmlzQXhpb3NFcnJvcikgcmV0dXJuIG5vcm1hbGl6ZUF4aW9zRXJyb3IoZXJyLCBcImdldCBjcmF3bCBzdGF0dXNcIik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBjYW5jZWxDcmF3bChodHRwLCBqb2JJZCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAuZGVsZXRlKGAvdjIvY3Jhd2wvJHtqb2JJZH1gKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB0aHJvd0ZvckJhZFJlc3BvbnNlKHJlcywgXCJjYW5jZWwgY3Jhd2xcIik7XG4gICAgcmV0dXJuIHJlcy5kYXRhPy5zdGF0dXMgPT09IFwiY2FuY2VsbGVkXCI7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnI/LmlzQXhpb3NFcnJvcikgcmV0dXJuIG5vcm1hbGl6ZUF4aW9zRXJyb3IoZXJyLCBcImNhbmNlbCBjcmF3bFwiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JDcmF3bENvbXBsZXRpb24oaHR0cCwgam9iSWQsIHBvbGxJbnRlcnZhbCA9IDIsIHRpbWVvdXQpIHtcbiAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGdldENyYXdsU3RhdHVzKGh0dHAsIGpvYklkKTtcbiAgICBpZiAoW1wiY29tcGxldGVkXCIsIFwiZmFpbGVkXCIsIFwiY2FuY2VsbGVkXCJdLmluY2x1ZGVzKHN0YXR1cy5zdGF0dXMpKSByZXR1cm4gc3RhdHVzO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCAqIDFlMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDcmF3bCBqb2IgJHtqb2JJZH0gZGlkIG5vdCBjb21wbGV0ZSB3aXRoaW4gJHt0aW1lb3V0fSBzZWNvbmRzYCk7XG4gICAgfVxuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIE1hdGgubWF4KDFlMywgcG9sbEludGVydmFsICogMWUzKSkpO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBjcmF3bChodHRwLCByZXF1ZXN0LCBwb2xsSW50ZXJ2YWwgPSAyLCB0aW1lb3V0KSB7XG4gIGNvbnN0IHN0YXJ0ZWQgPSBhd2FpdCBzdGFydENyYXdsKGh0dHAsIHJlcXVlc3QpO1xuICByZXR1cm4gd2FpdEZvckNyYXdsQ29tcGxldGlvbihodHRwLCBzdGFydGVkLmlkLCBwb2xsSW50ZXJ2YWwsIHRpbWVvdXQpO1xufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Q3Jhd2xFcnJvcnMoaHR0cCwgY3Jhd2xJZCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAuZ2V0KGAvdjIvY3Jhd2wvJHtjcmF3bElkfS9lcnJvcnNgKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB0aHJvd0ZvckJhZFJlc3BvbnNlKHJlcywgXCJnZXQgY3Jhd2wgZXJyb3JzXCIpO1xuICAgIGNvbnN0IHBheWxvYWQgPSByZXMuZGF0YT8uZGF0YSA/PyByZXMuZGF0YTtcbiAgICByZXR1cm4geyBlcnJvcnM6IHBheWxvYWQuZXJyb3JzIHx8IFtdLCByb2JvdHNCbG9ja2VkOiBwYXlsb2FkLnJvYm90c0Jsb2NrZWQgfHwgW10gfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVycj8uaXNBeGlvc0Vycm9yKSByZXR1cm4gbm9ybWFsaXplQXhpb3NFcnJvcihlcnIsIFwiZ2V0IGNyYXdsIGVycm9yc1wiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEFjdGl2ZUNyYXdscyhodHRwKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaHR0cC5nZXQoYC92Mi9jcmF3bC9hY3RpdmVgKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXMuZGF0YT8uc3VjY2VzcykgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwiZ2V0IGFjdGl2ZSBjcmF3bHNcIik7XG4gICAgY29uc3QgY3Jhd2xzSW4gPSByZXMuZGF0YT8uY3Jhd2xzIHx8IFtdO1xuICAgIGNvbnN0IGNyYXdscyA9IGNyYXdsc0luLm1hcCgoYykgPT4gKHsgaWQ6IGMuaWQsIHRlYW1JZDogYy50ZWFtSWQgPz8gYy50ZWFtX2lkLCB1cmw6IGMudXJsLCBvcHRpb25zOiBjLm9wdGlvbnMgPz8gbnVsbCB9KSk7XG4gICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgY3Jhd2xzIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnI/LmlzQXhpb3NFcnJvcikgcmV0dXJuIG5vcm1hbGl6ZUF4aW9zRXJyb3IoZXJyLCBcImdldCBhY3RpdmUgY3Jhd2xzXCIpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gY3Jhd2xQYXJhbXNQcmV2aWV3KGh0dHAsIHVybCwgcHJvbXB0KSB7XG4gIGlmICghdXJsIHx8ICF1cmwudHJpbSgpKSB0aHJvdyBuZXcgRXJyb3IoXCJVUkwgY2Fubm90IGJlIGVtcHR5XCIpO1xuICBpZiAoIXByb21wdCB8fCAhcHJvbXB0LnRyaW0oKSkgdGhyb3cgbmV3IEVycm9yKFwiUHJvbXB0IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBodHRwLnBvc3QoXCIvdjIvY3Jhd2wvcGFyYW1zLXByZXZpZXdcIiwgeyB1cmw6IHVybC50cmltKCksIHByb21wdCB9KTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXMuZGF0YT8uc3VjY2VzcykgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwiY3Jhd2wgcGFyYW1zIHByZXZpZXdcIik7XG4gICAgY29uc3QgZGF0YSA9IHJlcy5kYXRhLmRhdGEgfHwge307XG4gICAgaWYgKHJlcy5kYXRhLndhcm5pbmcpIGRhdGEud2FybmluZyA9IHJlcy5kYXRhLndhcm5pbmc7XG4gICAgcmV0dXJuIGRhdGE7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnI/LmlzQXhpb3NFcnJvcikgcmV0dXJuIG5vcm1hbGl6ZUF4aW9zRXJyb3IoZXJyLCBcImNyYXdsIHBhcmFtcyBwcmV2aWV3XCIpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuXG4vLyBzcmMvdjIvbWV0aG9kcy9iYXRjaC50c1xuYXN5bmMgZnVuY3Rpb24gc3RhcnRCYXRjaFNjcmFwZShodHRwLCB1cmxzLCB7XG4gIG9wdGlvbnMsXG4gIHdlYmhvb2ssXG4gIGFwcGVuZFRvSWQsXG4gIGlnbm9yZUludmFsaWRVUkxzLFxuICBtYXhDb25jdXJyZW5jeSxcbiAgemVyb0RhdGFSZXRlbnRpb24sXG4gIGlkZW1wb3RlbmN5S2V5LFxuICBpbnRlZ3JhdGlvblxufSA9IHt9KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheSh1cmxzKSB8fCB1cmxzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IEVycm9yKFwiVVJMcyBsaXN0IGNhbm5vdCBiZSBlbXB0eVwiKTtcbiAgY29uc3QgcGF5bG9hZCA9IHsgdXJscyB9O1xuICBpZiAob3B0aW9ucykge1xuICAgIGVuc3VyZVZhbGlkU2NyYXBlT3B0aW9ucyhvcHRpb25zKTtcbiAgICBPYmplY3QuYXNzaWduKHBheWxvYWQsIG9wdGlvbnMpO1xuICB9XG4gIGlmICh3ZWJob29rICE9IG51bGwpIHBheWxvYWQud2ViaG9vayA9IHdlYmhvb2s7XG4gIGlmIChhcHBlbmRUb0lkICE9IG51bGwpIHBheWxvYWQuYXBwZW5kVG9JZCA9IGFwcGVuZFRvSWQ7XG4gIGlmIChpZ25vcmVJbnZhbGlkVVJMcyAhPSBudWxsKSBwYXlsb2FkLmlnbm9yZUludmFsaWRVUkxzID0gaWdub3JlSW52YWxpZFVSTHM7XG4gIGlmIChtYXhDb25jdXJyZW5jeSAhPSBudWxsKSBwYXlsb2FkLm1heENvbmN1cnJlbmN5ID0gbWF4Q29uY3VycmVuY3k7XG4gIGlmICh6ZXJvRGF0YVJldGVudGlvbiAhPSBudWxsKSBwYXlsb2FkLnplcm9EYXRhUmV0ZW50aW9uID0gemVyb0RhdGFSZXRlbnRpb247XG4gIGlmIChpbnRlZ3JhdGlvbiAhPSBudWxsICYmIGludGVncmF0aW9uLnRyaW0oKSkgcGF5bG9hZC5pbnRlZ3JhdGlvbiA9IGludGVncmF0aW9uLnRyaW0oKTtcbiAgdHJ5IHtcbiAgICBjb25zdCBoZWFkZXJzID0gaHR0cC5wcmVwYXJlSGVhZGVycyhpZGVtcG90ZW5jeUtleSk7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaHR0cC5wb3N0KFwiL3YyL2JhdGNoL3NjcmFwZVwiLCBwYXlsb2FkLCBoZWFkZXJzKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXMuZGF0YT8uc3VjY2VzcykgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwic3RhcnQgYmF0Y2ggc2NyYXBlXCIpO1xuICAgIHJldHVybiB7IGlkOiByZXMuZGF0YS5pZCwgdXJsOiByZXMuZGF0YS51cmwsIGludmFsaWRVUkxzOiByZXMuZGF0YS5pbnZhbGlkVVJMcyB8fCB2b2lkIDAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVycj8uaXNBeGlvc0Vycm9yKSByZXR1cm4gbm9ybWFsaXplQXhpb3NFcnJvcihlcnIsIFwic3RhcnQgYmF0Y2ggc2NyYXBlXCIpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0QmF0Y2hTY3JhcGVTdGF0dXMoaHR0cCwgam9iSWQsIHBhZ2luYXRpb24pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBodHRwLmdldChgL3YyL2JhdGNoL3NjcmFwZS8ke2pvYklkfWApO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDAgfHwgIXJlcy5kYXRhPy5zdWNjZXNzKSB0aHJvd0ZvckJhZFJlc3BvbnNlKHJlcywgXCJnZXQgYmF0Y2ggc2NyYXBlIHN0YXR1c1wiKTtcbiAgICBjb25zdCBib2R5ID0gcmVzLmRhdGE7XG4gICAgY29uc3QgaW5pdGlhbERvY3MgPSBib2R5LmRhdGEgfHwgW107XG4gICAgY29uc3QgYXV0byA9IHBhZ2luYXRpb24/LmF1dG9QYWdpbmF0ZSA/PyB0cnVlO1xuICAgIGlmICghYXV0byB8fCAhYm9keS5uZXh0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdGF0dXM6IGJvZHkuc3RhdHVzLFxuICAgICAgICBjb21wbGV0ZWQ6IGJvZHkuY29tcGxldGVkID8/IDAsXG4gICAgICAgIHRvdGFsOiBib2R5LnRvdGFsID8/IDAsXG4gICAgICAgIGNyZWRpdHNVc2VkOiBib2R5LmNyZWRpdHNVc2VkLFxuICAgICAgICBleHBpcmVzQXQ6IGJvZHkuZXhwaXJlc0F0LFxuICAgICAgICBuZXh0OiBib2R5Lm5leHQgPz8gbnVsbCxcbiAgICAgICAgZGF0YTogaW5pdGlhbERvY3NcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGFnZ3JlZ2F0ZWQgPSBhd2FpdCBmZXRjaEFsbFBhZ2VzKGh0dHAsIGJvZHkubmV4dCwgaW5pdGlhbERvY3MsIHBhZ2luYXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICBzdGF0dXM6IGJvZHkuc3RhdHVzLFxuICAgICAgY29tcGxldGVkOiBib2R5LmNvbXBsZXRlZCA/PyAwLFxuICAgICAgdG90YWw6IGJvZHkudG90YWwgPz8gMCxcbiAgICAgIGNyZWRpdHNVc2VkOiBib2R5LmNyZWRpdHNVc2VkLFxuICAgICAgZXhwaXJlc0F0OiBib2R5LmV4cGlyZXNBdCxcbiAgICAgIG5leHQ6IG51bGwsXG4gICAgICBkYXRhOiBhZ2dyZWdhdGVkXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVycj8uaXNBeGlvc0Vycm9yKSByZXR1cm4gbm9ybWFsaXplQXhpb3NFcnJvcihlcnIsIFwiZ2V0IGJhdGNoIHNjcmFwZSBzdGF0dXNcIik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBjYW5jZWxCYXRjaFNjcmFwZShodHRwLCBqb2JJZCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAuZGVsZXRlKGAvdjIvYmF0Y2gvc2NyYXBlLyR7am9iSWR9YCk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwiY2FuY2VsIGJhdGNoIHNjcmFwZVwiKTtcbiAgICByZXR1cm4gcmVzLmRhdGE/LnN0YXR1cyA9PT0gXCJjYW5jZWxsZWRcIjtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVycj8uaXNBeGlvc0Vycm9yKSByZXR1cm4gbm9ybWFsaXplQXhpb3NFcnJvcihlcnIsIFwiY2FuY2VsIGJhdGNoIHNjcmFwZVwiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEJhdGNoU2NyYXBlRXJyb3JzKGh0dHAsIGpvYklkKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaHR0cC5nZXQoYC92Mi9iYXRjaC9zY3JhcGUvJHtqb2JJZH0vZXJyb3JzYCk7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCkgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwiZ2V0IGJhdGNoIHNjcmFwZSBlcnJvcnNcIik7XG4gICAgY29uc3QgcGF5bG9hZCA9IHJlcy5kYXRhPy5kYXRhID8/IHJlcy5kYXRhO1xuICAgIHJldHVybiB7IGVycm9yczogcGF5bG9hZC5lcnJvcnMgfHwgW10sIHJvYm90c0Jsb2NrZWQ6IHBheWxvYWQucm9ib3RzQmxvY2tlZCB8fCBbXSB9O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyPy5pc0F4aW9zRXJyb3IpIHJldHVybiBub3JtYWxpemVBeGlvc0Vycm9yKGVyciwgXCJnZXQgYmF0Y2ggc2NyYXBlIGVycm9yc1wiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIHdhaXRGb3JCYXRjaENvbXBsZXRpb24oaHR0cCwgam9iSWQsIHBvbGxJbnRlcnZhbCA9IDIsIHRpbWVvdXQpIHtcbiAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGdldEJhdGNoU2NyYXBlU3RhdHVzKGh0dHAsIGpvYklkKTtcbiAgICBpZiAoW1wiY29tcGxldGVkXCIsIFwiZmFpbGVkXCIsIFwiY2FuY2VsbGVkXCJdLmluY2x1ZGVzKHN0YXR1cy5zdGF0dXMpKSByZXR1cm4gc3RhdHVzO1xuICAgIGlmICh0aW1lb3V0ICE9IG51bGwgJiYgRGF0ZS5ub3coKSAtIHN0YXJ0ID4gdGltZW91dCAqIDFlMykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYXRjaCBzY3JhcGUgam9iICR7am9iSWR9IGRpZCBub3QgY29tcGxldGUgd2l0aGluICR7dGltZW91dH0gc2Vjb25kc2ApO1xuICAgIH1cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocikgPT4gc2V0VGltZW91dChyLCBNYXRoLm1heCgxZTMsIHBvbGxJbnRlcnZhbCAqIDFlMykpKTtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gYmF0Y2hTY3JhcGUoaHR0cCwgdXJscywgb3B0cyA9IHt9KSB7XG4gIGNvbnN0IHN0YXJ0ID0gYXdhaXQgc3RhcnRCYXRjaFNjcmFwZShodHRwLCB1cmxzLCBvcHRzKTtcbiAgcmV0dXJuIHdhaXRGb3JCYXRjaENvbXBsZXRpb24oaHR0cCwgc3RhcnQuaWQsIG9wdHMucG9sbEludGVydmFsID8/IDIsIG9wdHMudGltZW91dCk7XG59XG5cbi8vIHNyYy92Mi9tZXRob2RzL2V4dHJhY3QudHNcbmltcG9ydCB7IHpvZFRvSnNvblNjaGVtYSBhcyB6b2RUb0pzb25TY2hlbWEyIH0gZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuZnVuY3Rpb24gcHJlcGFyZUV4dHJhY3RQYXlsb2FkKGFyZ3MpIHtcbiAgY29uc3QgYm9keSA9IHt9O1xuICBpZiAoYXJncy51cmxzKSBib2R5LnVybHMgPSBhcmdzLnVybHM7XG4gIGlmIChhcmdzLnByb21wdCAhPSBudWxsKSBib2R5LnByb21wdCA9IGFyZ3MucHJvbXB0O1xuICBpZiAoYXJncy5zY2hlbWEgIT0gbnVsbCkge1xuICAgIGNvbnN0IHMgPSBhcmdzLnNjaGVtYTtcbiAgICBjb25zdCBpc1pvZCA9IHMgJiYgKHR5cGVvZiBzLnNhZmVQYXJzZSA9PT0gXCJmdW5jdGlvblwiIHx8IHR5cGVvZiBzLnBhcnNlID09PSBcImZ1bmN0aW9uXCIpICYmIHMuX2RlZjtcbiAgICBib2R5LnNjaGVtYSA9IGlzWm9kID8gem9kVG9Kc29uU2NoZW1hMihzKSA6IGFyZ3Muc2NoZW1hO1xuICB9XG4gIGlmIChhcmdzLnN5c3RlbVByb21wdCAhPSBudWxsKSBib2R5LnN5c3RlbVByb21wdCA9IGFyZ3Muc3lzdGVtUHJvbXB0O1xuICBpZiAoYXJncy5hbGxvd0V4dGVybmFsTGlua3MgIT0gbnVsbCkgYm9keS5hbGxvd0V4dGVybmFsTGlua3MgPSBhcmdzLmFsbG93RXh0ZXJuYWxMaW5rcztcbiAgaWYgKGFyZ3MuZW5hYmxlV2ViU2VhcmNoICE9IG51bGwpIGJvZHkuZW5hYmxlV2ViU2VhcmNoID0gYXJncy5lbmFibGVXZWJTZWFyY2g7XG4gIGlmIChhcmdzLnNob3dTb3VyY2VzICE9IG51bGwpIGJvZHkuc2hvd1NvdXJjZXMgPSBhcmdzLnNob3dTb3VyY2VzO1xuICBpZiAoYXJncy5pZ25vcmVJbnZhbGlkVVJMcyAhPSBudWxsKSBib2R5Lmlnbm9yZUludmFsaWRVUkxzID0gYXJncy5pZ25vcmVJbnZhbGlkVVJMcztcbiAgaWYgKGFyZ3MuaW50ZWdyYXRpb24gJiYgYXJncy5pbnRlZ3JhdGlvbi50cmltKCkpIGJvZHkuaW50ZWdyYXRpb24gPSBhcmdzLmludGVncmF0aW9uLnRyaW0oKTtcbiAgaWYgKGFyZ3MuYWdlbnQpIGJvZHkuYWdlbnQgPSBhcmdzLmFnZW50O1xuICBpZiAoYXJncy5zY3JhcGVPcHRpb25zKSB7XG4gICAgZW5zdXJlVmFsaWRTY3JhcGVPcHRpb25zKGFyZ3Muc2NyYXBlT3B0aW9ucyk7XG4gICAgYm9keS5zY3JhcGVPcHRpb25zID0gYXJncy5zY3JhcGVPcHRpb25zO1xuICB9XG4gIHJldHVybiBib2R5O1xufVxuYXN5bmMgZnVuY3Rpb24gc3RhcnRFeHRyYWN0KGh0dHAsIGFyZ3MpIHtcbiAgY29uc3QgcGF5bG9hZCA9IHByZXBhcmVFeHRyYWN0UGF5bG9hZChhcmdzKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBodHRwLnBvc3QoXCIvdjIvZXh0cmFjdFwiLCBwYXlsb2FkKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB0aHJvd0ZvckJhZFJlc3BvbnNlKHJlcywgXCJleHRyYWN0XCIpO1xuICAgIHJldHVybiByZXMuZGF0YTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVycj8uaXNBeGlvc0Vycm9yKSByZXR1cm4gbm9ybWFsaXplQXhpb3NFcnJvcihlcnIsIFwiZXh0cmFjdFwiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEV4dHJhY3RTdGF0dXMoaHR0cCwgam9iSWQpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBodHRwLmdldChgL3YyL2V4dHJhY3QvJHtqb2JJZH1gKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwKSB0aHJvd0ZvckJhZFJlc3BvbnNlKHJlcywgXCJleHRyYWN0IHN0YXR1c1wiKTtcbiAgICByZXR1cm4gcmVzLmRhdGE7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnI/LmlzQXhpb3NFcnJvcikgcmV0dXJuIG5vcm1hbGl6ZUF4aW9zRXJyb3IoZXJyLCBcImV4dHJhY3Qgc3RhdHVzXCIpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gd2FpdEV4dHJhY3QoaHR0cCwgam9iSWQsIHBvbGxJbnRlcnZhbCA9IDIsIHRpbWVvdXQpIHtcbiAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHN0YXR1cyA9IGF3YWl0IGdldEV4dHJhY3RTdGF0dXMoaHR0cCwgam9iSWQpO1xuICAgIGlmIChbXCJjb21wbGV0ZWRcIiwgXCJmYWlsZWRcIiwgXCJjYW5jZWxsZWRcIl0uaW5jbHVkZXMoc3RhdHVzLnN0YXR1cyB8fCBcIlwiKSkgcmV0dXJuIHN0YXR1cztcbiAgICBpZiAodGltZW91dCAhPSBudWxsICYmIERhdGUubm93KCkgLSBzdGFydCA+IHRpbWVvdXQgKiAxZTMpIHJldHVybiBzdGF0dXM7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHNldFRpbWVvdXQociwgTWF0aC5tYXgoMWUzLCBwb2xsSW50ZXJ2YWwgKiAxZTMpKSk7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGV4dHJhY3QoaHR0cCwgYXJncykge1xuICBjb25zdCBzdGFydGVkID0gYXdhaXQgc3RhcnRFeHRyYWN0KGh0dHAsIGFyZ3MpO1xuICBjb25zdCBqb2JJZCA9IHN0YXJ0ZWQuaWQ7XG4gIGlmICgham9iSWQpIHJldHVybiBzdGFydGVkO1xuICByZXR1cm4gd2FpdEV4dHJhY3QoaHR0cCwgam9iSWQsIGFyZ3MucG9sbEludGVydmFsID8/IDIsIGFyZ3MudGltZW91dCk7XG59XG5cbi8vIHNyYy92Mi9tZXRob2RzL3VzYWdlLnRzXG5hc3luYyBmdW5jdGlvbiBnZXRDb25jdXJyZW5jeShodHRwKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgaHR0cC5nZXQoXCIvdjIvY29uY3VycmVuY3ktY2hlY2tcIik7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCB8fCAhcmVzLmRhdGE/LnN1Y2Nlc3MpIHRocm93Rm9yQmFkUmVzcG9uc2UocmVzLCBcImdldCBjb25jdXJyZW5jeVwiKTtcbiAgICBjb25zdCBkID0gcmVzLmRhdGEuZGF0YSB8fCByZXMuZGF0YTtcbiAgICByZXR1cm4geyBjb25jdXJyZW5jeTogZC5jb25jdXJyZW5jeSwgbWF4Q29uY3VycmVuY3k6IGQubWF4Q29uY3VycmVuY3kgPz8gZC5tYXhfY29uY3VycmVuY3kgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVycj8uaXNBeGlvc0Vycm9yKSByZXR1cm4gbm9ybWFsaXplQXhpb3NFcnJvcihlcnIsIFwiZ2V0IGNvbmN1cnJlbmN5XCIpO1xuICAgIHRocm93IGVycjtcbiAgfVxufVxuYXN5bmMgZnVuY3Rpb24gZ2V0Q3JlZGl0VXNhZ2UoaHR0cCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAuZ2V0KFwiL3YyL3RlYW0vY3JlZGl0LXVzYWdlXCIpO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDAgfHwgIXJlcy5kYXRhPy5zdWNjZXNzKSB0aHJvd0ZvckJhZFJlc3BvbnNlKHJlcywgXCJnZXQgY3JlZGl0IHVzYWdlXCIpO1xuICAgIGNvbnN0IGQgPSByZXMuZGF0YS5kYXRhIHx8IHJlcy5kYXRhO1xuICAgIHJldHVybiB7XG4gICAgICByZW1haW5pbmdDcmVkaXRzOiBkLnJlbWFpbmluZ0NyZWRpdHMgPz8gZC5yZW1haW5pbmdfY3JlZGl0cyA/PyAwLFxuICAgICAgcGxhbkNyZWRpdHM6IGQucGxhbkNyZWRpdHMgPz8gZC5wbGFuX2NyZWRpdHMsXG4gICAgICBiaWxsaW5nUGVyaW9kU3RhcnQ6IGQuYmlsbGluZ1BlcmlvZFN0YXJ0ID8/IGQuYmlsbGluZ19wZXJpb2Rfc3RhcnQgPz8gbnVsbCxcbiAgICAgIGJpbGxpbmdQZXJpb2RFbmQ6IGQuYmlsbGluZ1BlcmlvZEVuZCA/PyBkLmJpbGxpbmdfcGVyaW9kX2VuZCA/PyBudWxsXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgaWYgKGVycj8uaXNBeGlvc0Vycm9yKSByZXR1cm4gbm9ybWFsaXplQXhpb3NFcnJvcihlcnIsIFwiZ2V0IGNyZWRpdCB1c2FnZVwiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFRva2VuVXNhZ2UoaHR0cCkge1xuICB0cnkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAuZ2V0KFwiL3YyL3RlYW0vdG9rZW4tdXNhZ2VcIik7XG4gICAgaWYgKHJlcy5zdGF0dXMgIT09IDIwMCB8fCAhcmVzLmRhdGE/LnN1Y2Nlc3MpIHRocm93Rm9yQmFkUmVzcG9uc2UocmVzLCBcImdldCB0b2tlbiB1c2FnZVwiKTtcbiAgICBjb25zdCBkID0gcmVzLmRhdGEuZGF0YSB8fCByZXMuZGF0YTtcbiAgICByZXR1cm4ge1xuICAgICAgcmVtYWluaW5nVG9rZW5zOiBkLnJlbWFpbmluZ1Rva2VucyA/PyBkLnJlbWFpbmluZ190b2tlbnMgPz8gMCxcbiAgICAgIHBsYW5Ub2tlbnM6IGQucGxhblRva2VucyA/PyBkLnBsYW5fdG9rZW5zLFxuICAgICAgYmlsbGluZ1BlcmlvZFN0YXJ0OiBkLmJpbGxpbmdQZXJpb2RTdGFydCA/PyBkLmJpbGxpbmdfcGVyaW9kX3N0YXJ0ID8/IG51bGwsXG4gICAgICBiaWxsaW5nUGVyaW9kRW5kOiBkLmJpbGxpbmdQZXJpb2RFbmQgPz8gZC5iaWxsaW5nX3BlcmlvZF9lbmQgPz8gbnVsbFxuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnI/LmlzQXhpb3NFcnJvcikgcmV0dXJuIG5vcm1hbGl6ZUF4aW9zRXJyb3IoZXJyLCBcImdldCB0b2tlbiB1c2FnZVwiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGdldFF1ZXVlU3RhdHVzKGh0dHApIHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBodHRwLmdldChcIi92Mi90ZWFtL3F1ZXVlLXN0YXR1c1wiKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXMuZGF0YT8uc3VjY2VzcykgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwiZ2V0IHF1ZXVlIHN0YXR1c1wiKTtcbiAgICByZXR1cm4gcmVzLmRhdGE7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnI/LmlzQXhpb3NFcnJvcikgcmV0dXJuIG5vcm1hbGl6ZUF4aW9zRXJyb3IoZXJyLCBcImdldCBxdWV1ZSBzdGF0dXNcIik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRDcmVkaXRVc2FnZUhpc3RvcmljYWwoaHR0cCwgYnlBcGlLZXkpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBxdWVyeSA9IGJ5QXBpS2V5ID8gXCI/YnlBcGlLZXk9dHJ1ZVwiIDogXCJcIjtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBodHRwLmdldChgL3YyL3RlYW0vY3JlZGl0LXVzYWdlL2hpc3RvcmljYWwke3F1ZXJ5fWApO1xuICAgIGlmIChyZXMuc3RhdHVzICE9PSAyMDAgfHwgIXJlcy5kYXRhPy5zdWNjZXNzKSB0aHJvd0ZvckJhZFJlc3BvbnNlKHJlcywgXCJnZXQgY3JlZGl0IHVzYWdlIGhpc3RvcmljYWxcIik7XG4gICAgcmV0dXJuIHJlcy5kYXRhO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyPy5pc0F4aW9zRXJyb3IpIHJldHVybiBub3JtYWxpemVBeGlvc0Vycm9yKGVyciwgXCJnZXQgY3JlZGl0IHVzYWdlIGhpc3RvcmljYWxcIik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXRUb2tlblVzYWdlSGlzdG9yaWNhbChodHRwLCBieUFwaUtleSkge1xuICB0cnkge1xuICAgIGNvbnN0IHF1ZXJ5ID0gYnlBcGlLZXkgPyBcIj9ieUFwaUtleT10cnVlXCIgOiBcIlwiO1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGh0dHAuZ2V0KGAvdjIvdGVhbS90b2tlbi11c2FnZS9oaXN0b3JpY2FsJHtxdWVyeX1gKTtcbiAgICBpZiAocmVzLnN0YXR1cyAhPT0gMjAwIHx8ICFyZXMuZGF0YT8uc3VjY2VzcykgdGhyb3dGb3JCYWRSZXNwb25zZShyZXMsIFwiZ2V0IHRva2VuIHVzYWdlIGhpc3RvcmljYWxcIik7XG4gICAgcmV0dXJuIHJlcy5kYXRhO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyPy5pc0F4aW9zRXJyb3IpIHJldHVybiBub3JtYWxpemVBeGlvc0Vycm9yKGVyciwgXCJnZXQgdG9rZW4gdXNhZ2UgaGlzdG9yaWNhbFwiKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cblxuLy8gc3JjL3YyL3dhdGNoZXIudHNcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gXCJldmVudHNcIjtcbnZhciBXYXRjaGVyID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBodHRwO1xuICBqb2JJZDtcbiAga2luZDtcbiAgcG9sbEludGVydmFsO1xuICB0aW1lb3V0O1xuICB3cztcbiAgY2xvc2VkID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKGh0dHAsIGpvYklkLCBvcHRzID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaHR0cCA9IGh0dHA7XG4gICAgdGhpcy5qb2JJZCA9IGpvYklkO1xuICAgIHRoaXMua2luZCA9IG9wdHMua2luZCA/PyBcImNyYXdsXCI7XG4gICAgdGhpcy5wb2xsSW50ZXJ2YWwgPSBvcHRzLnBvbGxJbnRlcnZhbCA/PyAyO1xuICAgIHRoaXMudGltZW91dCA9IG9wdHMudGltZW91dDtcbiAgfVxuICBidWlsZFdzVXJsKCkge1xuICAgIGNvbnN0IGFwaVVybCA9IHRoaXMuaHR0cC5nZXRBcGlVcmwoKTtcbiAgICBjb25zdCB3c0Jhc2UgPSBhcGlVcmwucmVwbGFjZSgvXmh0dHAvLCBcIndzXCIpO1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmtpbmQgPT09IFwiY3Jhd2xcIiA/IGAvdjIvY3Jhd2wvJHt0aGlzLmpvYklkfWAgOiBgL3YyL2JhdGNoL3NjcmFwZS8ke3RoaXMuam9iSWR9YDtcbiAgICByZXR1cm4gYCR7d3NCYXNlfSR7cGF0aH1gO1xuICB9XG4gIGFzeW5jIHN0YXJ0KCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkV3NVcmwoKTtcbiAgICAgIHRoaXMud3MgPSBuZXcgV2ViU29ja2V0KHVybCwgdGhpcy5odHRwLmdldEFwaUtleSgpKTtcbiAgICAgIHRoaXMuYXR0YWNoV3NIYW5kbGVycyh0aGlzLndzKTtcbiAgICB9IGNhdGNoIHtcbiAgICAgIHRoaXMucG9sbExvb3AoKTtcbiAgICB9XG4gIH1cbiAgYXR0YWNoV3NIYW5kbGVycyh3cykge1xuICAgIGxldCBzdGFydFRzID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lb3V0TXMgPSB0aGlzLnRpbWVvdXQgPyB0aGlzLnRpbWVvdXQgKiAxZTMgOiB2b2lkIDA7XG4gICAgd3Mub25tZXNzYWdlID0gKGV2KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBib2R5ID0gdHlwZW9mIGV2LmRhdGEgPT09IFwic3RyaW5nXCIgPyBKU09OLnBhcnNlKGV2LmRhdGEpIDogbnVsbDtcbiAgICAgICAgaWYgKCFib2R5KSByZXR1cm47XG4gICAgICAgIGNvbnN0IHR5cGUgPSBib2R5LnR5cGU7XG4gICAgICAgIGlmICh0eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCB7IHN0YXR1czogXCJmYWlsZWRcIiwgZGF0YTogW10sIGVycm9yOiBib2R5LmVycm9yLCBpZDogdGhpcy5qb2JJZCB9KTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiY2F0Y2h1cFwiKSB7XG4gICAgICAgICAgY29uc3QgcGF5bG9hZDIgPSBib2R5LmRhdGEgfHwge307XG4gICAgICAgICAgdGhpcy5lbWl0RG9jdW1lbnRzKHBheWxvYWQyLmRhdGEgfHwgW10pO1xuICAgICAgICAgIHRoaXMuZW1pdFNuYXBzaG90KHBheWxvYWQyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGUgPT09IFwiZG9jdW1lbnRcIikge1xuICAgICAgICAgIGNvbnN0IGRvYyA9IGJvZHkuZGF0YTtcbiAgICAgICAgICBpZiAoZG9jKSB0aGlzLmVtaXQoXCJkb2N1bWVudFwiLCBkb2MpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gXCJkb25lXCIpIHtcbiAgICAgICAgICB0aGlzLmVtaXQoXCJkb25lXCIsIHsgc3RhdHVzOiBcImNvbXBsZXRlZFwiLCBkYXRhOiBbXSwgaWQ6IHRoaXMuam9iSWQgfSk7XG4gICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXlsb2FkID0gYm9keS5kYXRhIHx8IGJvZHk7XG4gICAgICAgIGlmIChwYXlsb2FkICYmIHBheWxvYWQuc3RhdHVzKSB0aGlzLmVtaXRTbmFwc2hvdChwYXlsb2FkKTtcbiAgICAgIH0gY2F0Y2gge1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVvdXRNcyAmJiBEYXRlLm5vdygpIC0gc3RhcnRUcyA+IHRpbWVvdXRNcykgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgd3Mub25lcnJvciA9ICgpID0+IHtcbiAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIHsgc3RhdHVzOiBcImZhaWxlZFwiLCBkYXRhOiBbXSwgZXJyb3I6IFwiV2ViU29ja2V0IGVycm9yXCIsIGlkOiB0aGlzLmpvYklkIH0pO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH07XG4gICAgd3Mub25jbG9zZSA9ICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5jbG9zZWQpIHRoaXMucG9sbExvb3AoKTtcbiAgICB9O1xuICB9XG4gIGVtaXREb2N1bWVudHMoZG9jcykge1xuICAgIGZvciAoY29uc3QgZG9jIG9mIGRvY3MpIHRoaXMuZW1pdChcImRvY3VtZW50XCIsIHsgLi4uZG9jLCBpZDogdGhpcy5qb2JJZCB9KTtcbiAgfVxuICBlbWl0U25hcHNob3QocGF5bG9hZCkge1xuICAgIGNvbnN0IHN0YXR1cyA9IHBheWxvYWQuc3RhdHVzO1xuICAgIGNvbnN0IGRhdGEgPSBwYXlsb2FkLmRhdGEgfHwgW107XG4gICAgY29uc3Qgc25hcCA9IHRoaXMua2luZCA9PT0gXCJjcmF3bFwiID8ge1xuICAgICAgc3RhdHVzLFxuICAgICAgY29tcGxldGVkOiBwYXlsb2FkLmNvbXBsZXRlZCA/PyAwLFxuICAgICAgdG90YWw6IHBheWxvYWQudG90YWwgPz8gMCxcbiAgICAgIGNyZWRpdHNVc2VkOiBwYXlsb2FkLmNyZWRpdHNVc2VkLFxuICAgICAgZXhwaXJlc0F0OiBwYXlsb2FkLmV4cGlyZXNBdCxcbiAgICAgIG5leHQ6IHBheWxvYWQubmV4dCA/PyBudWxsLFxuICAgICAgZGF0YVxuICAgIH0gOiB7XG4gICAgICBzdGF0dXMsXG4gICAgICBjb21wbGV0ZWQ6IHBheWxvYWQuY29tcGxldGVkID8/IDAsXG4gICAgICB0b3RhbDogcGF5bG9hZC50b3RhbCA/PyAwLFxuICAgICAgY3JlZGl0c1VzZWQ6IHBheWxvYWQuY3JlZGl0c1VzZWQsXG4gICAgICBleHBpcmVzQXQ6IHBheWxvYWQuZXhwaXJlc0F0LFxuICAgICAgbmV4dDogcGF5bG9hZC5uZXh0ID8/IG51bGwsXG4gICAgICBkYXRhXG4gICAgfTtcbiAgICB0aGlzLmVtaXQoXCJzbmFwc2hvdFwiLCBzbmFwKTtcbiAgICBpZiAoW1wiY29tcGxldGVkXCIsIFwiZmFpbGVkXCIsIFwiY2FuY2VsbGVkXCJdLmluY2x1ZGVzKHN0YXR1cykpIHtcbiAgICAgIHRoaXMuZW1pdChcImRvbmVcIiwgeyBzdGF0dXMsIGRhdGEsIGlkOiB0aGlzLmpvYklkIH0pO1xuICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgfVxuICBhc3luYyBwb2xsTG9vcCgpIHtcbiAgICBjb25zdCBzdGFydFRzID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCB0aW1lb3V0TXMgPSB0aGlzLnRpbWVvdXQgPyB0aGlzLnRpbWVvdXQgKiAxZTMgOiB2b2lkIDA7XG4gICAgd2hpbGUgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc25hcCA9IHRoaXMua2luZCA9PT0gXCJjcmF3bFwiID8gYXdhaXQgZ2V0Q3Jhd2xTdGF0dXModGhpcy5odHRwLCB0aGlzLmpvYklkKSA6IGF3YWl0IGdldEJhdGNoU2NyYXBlU3RhdHVzKHRoaXMuaHR0cCwgdGhpcy5qb2JJZCk7XG4gICAgICAgIHRoaXMuZW1pdChcInNuYXBzaG90XCIsIHNuYXApO1xuICAgICAgICBpZiAoW1wiY29tcGxldGVkXCIsIFwiZmFpbGVkXCIsIFwiY2FuY2VsbGVkXCJdLmluY2x1ZGVzKHNuYXAuc3RhdHVzKSkge1xuICAgICAgICAgIHRoaXMuZW1pdChcImRvbmVcIiwgeyBzdGF0dXM6IHNuYXAuc3RhdHVzLCBkYXRhOiBzbmFwLmRhdGEsIGlkOiB0aGlzLmpvYklkIH0pO1xuICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCB7XG4gICAgICB9XG4gICAgICBpZiAodGltZW91dE1zICYmIERhdGUubm93KCkgLSBzdGFydFRzID4gdGltZW91dE1zKSBicmVhaztcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyKSA9PiBzZXRUaW1lb3V0KHIsIE1hdGgubWF4KDFlMywgdGhpcy5wb2xsSW50ZXJ2YWwgKiAxZTMpKSk7XG4gICAgfVxuICB9XG4gIGNsb3NlKCkge1xuICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy53cyAmJiB0aGlzLndzLmNsb3NlKSB0aGlzLndzLmNsb3NlKCk7XG4gIH1cbn07XG5cbi8vIHNyYy92Mi9jbGllbnQudHNcbmltcG9ydCBcInpvZFwiO1xudmFyIEZpcmVjcmF3bENsaWVudCA9IGNsYXNzIHtcbiAgaHR0cDtcbiAgaXNDbG91ZFNlcnZpY2UodXJsKSB7XG4gICAgcmV0dXJuIHVybC5pbmNsdWRlcyhcImFwaS5maXJlY3Jhd2wuZGV2XCIpO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGUgYSB2MiBjbGllbnQuXG4gICAqIEBwYXJhbSBvcHRpb25zIFRyYW5zcG9ydCBjb25maWd1cmF0aW9uIChBUEkga2V5LCBiYXNlIFVSTCwgdGltZW91dHMsIHJldHJpZXMpLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgY29uc3QgYXBpS2V5ID0gb3B0aW9ucy5hcGlLZXkgPz8gcHJvY2Vzcy5lbnYuRklSRUNSQVdMX0FQSV9LRVkgPz8gXCJcIjtcbiAgICBjb25zdCBhcGlVcmwgPSAob3B0aW9ucy5hcGlVcmwgPz8gcHJvY2Vzcy5lbnYuRklSRUNSQVdMX0FQSV9VUkwgPz8gXCJodHRwczovL2FwaS5maXJlY3Jhd2wuZGV2XCIpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgICBpZiAodGhpcy5pc0Nsb3VkU2VydmljZShhcGlVcmwpICYmICFhcGlLZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkFQSSBrZXkgaXMgcmVxdWlyZWQgZm9yIHRoZSBjbG91ZCBBUEkuIFNldCBGSVJFQ1JBV0xfQVBJX0tFWSBlbnYgb3IgcGFzcyBhcGlLZXkuXCIpO1xuICAgIH1cbiAgICB0aGlzLmh0dHAgPSBuZXcgSHR0cENsaWVudCh7XG4gICAgICBhcGlLZXksXG4gICAgICBhcGlVcmwsXG4gICAgICB0aW1lb3V0TXM6IG9wdGlvbnMudGltZW91dE1zLFxuICAgICAgbWF4UmV0cmllczogb3B0aW9ucy5tYXhSZXRyaWVzLFxuICAgICAgYmFja29mZkZhY3Rvcjogb3B0aW9ucy5iYWNrb2ZmRmFjdG9yXG4gICAgfSk7XG4gIH1cbiAgYXN5bmMgc2NyYXBlKHVybCwgb3B0aW9ucykge1xuICAgIHJldHVybiBzY3JhcGUodGhpcy5odHRwLCB1cmwsIG9wdGlvbnMpO1xuICB9XG4gIC8vIFNlYXJjaFxuICAvKipcbiAgICogU2VhcmNoIHRoZSB3ZWIgYW5kIG9wdGlvbmFsbHkgc2NyYXBlIGVhY2ggcmVzdWx0LlxuICAgKiBAcGFyYW0gcXVlcnkgU2VhcmNoIHF1ZXJ5IHN0cmluZy5cbiAgICogQHBhcmFtIHJlcSBBZGRpdGlvbmFsIHNlYXJjaCBvcHRpb25zIChzb3VyY2VzLCBsaW1pdCwgc2NyYXBlT3B0aW9ucywgZXRjLikuXG4gICAqIEByZXR1cm5zIFN0cnVjdHVyZWQgc2VhcmNoIHJlc3VsdHMuXG4gICAqL1xuICBhc3luYyBzZWFyY2gocXVlcnksIHJlcSA9IHt9KSB7XG4gICAgcmV0dXJuIHNlYXJjaCh0aGlzLmh0dHAsIHsgcXVlcnksIC4uLnJlcSB9KTtcbiAgfVxuICAvLyBNYXBcbiAgLyoqXG4gICAqIE1hcCBhIHNpdGUgdG8gZGlzY292ZXIgVVJMcyAoc2l0ZW1hcC1hd2FyZSkuXG4gICAqIEBwYXJhbSB1cmwgUm9vdCBVUkwgdG8gbWFwLlxuICAgKiBAcGFyYW0gb3B0aW9ucyBNYXBwaW5nIG9wdGlvbnMgKHNpdGVtYXAgbW9kZSwgaW5jbHVkZVN1YmRvbWFpbnMsIGxpbWl0LCB0aW1lb3V0KS5cbiAgICogQHJldHVybnMgRGlzY292ZXJlZCBsaW5rcy5cbiAgICovXG4gIGFzeW5jIG1hcCh1cmwsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbWFwKHRoaXMuaHR0cCwgdXJsLCBvcHRpb25zKTtcbiAgfVxuICAvLyBDcmF3bFxuICAvKipcbiAgICogU3RhcnQgYSBjcmF3bCBqb2IgKGFzeW5jKS5cbiAgICogQHBhcmFtIHVybCBSb290IFVSTCB0byBjcmF3bC5cbiAgICogQHBhcmFtIHJlcSBDcmF3bCBjb25maWd1cmF0aW9uIChwYXRocywgbGltaXRzLCBzY3JhcGVPcHRpb25zLCB3ZWJob29rLCBldGMuKS5cbiAgICogQHJldHVybnMgSm9iIGlkIGFuZCB1cmwuXG4gICAqL1xuICBhc3luYyBzdGFydENyYXdsKHVybCwgcmVxID0ge30pIHtcbiAgICByZXR1cm4gc3RhcnRDcmF3bCh0aGlzLmh0dHAsIHsgdXJsLCAuLi5yZXEgfSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldCB0aGUgc3RhdHVzIGFuZCBwYXJ0aWFsIGRhdGEgb2YgYSBjcmF3bCBqb2IuXG4gICAqIEBwYXJhbSBqb2JJZCBDcmF3bCBqb2IgaWQuXG4gICAqL1xuICBhc3luYyBnZXRDcmF3bFN0YXR1cyhqb2JJZCwgcGFnaW5hdGlvbikge1xuICAgIHJldHVybiBnZXRDcmF3bFN0YXR1cyh0aGlzLmh0dHAsIGpvYklkLCBwYWdpbmF0aW9uKTtcbiAgfVxuICAvKipcbiAgICogQ2FuY2VsIGEgY3Jhd2wgam9iLlxuICAgKiBAcGFyYW0gam9iSWQgQ3Jhd2wgam9iIGlkLlxuICAgKiBAcmV0dXJucyBUcnVlIGlmIGNhbmNlbGxlZC5cbiAgICovXG4gIGFzeW5jIGNhbmNlbENyYXdsKGpvYklkKSB7XG4gICAgcmV0dXJuIGNhbmNlbENyYXdsKHRoaXMuaHR0cCwgam9iSWQpO1xuICB9XG4gIC8qKlxuICAgKiBDb252ZW5pZW5jZSB3YWl0ZXI6IHN0YXJ0IGEgY3Jhd2wgYW5kIHBvbGwgdW50aWwgaXQgZmluaXNoZXMuXG4gICAqIEBwYXJhbSB1cmwgUm9vdCBVUkwgdG8gY3Jhd2wuXG4gICAqIEBwYXJhbSByZXEgQ3Jhd2wgY29uZmlndXJhdGlvbiBwbHVzIHdhaXRlciBjb250cm9scyAocG9sbEludGVydmFsLCB0aW1lb3V0IHNlY29uZHMpLlxuICAgKiBAcmV0dXJucyBGaW5hbCBqb2Igc25hcHNob3QuXG4gICAqL1xuICBhc3luYyBjcmF3bCh1cmwsIHJlcSA9IHt9KSB7XG4gICAgcmV0dXJuIGNyYXdsKHRoaXMuaHR0cCwgeyB1cmwsIC4uLnJlcSB9LCByZXEucG9sbEludGVydmFsLCByZXEudGltZW91dCk7XG4gIH1cbiAgLyoqXG4gICAqIFJldHJpZXZlIGNyYXdsIGVycm9ycyBhbmQgcm9ib3RzLnR4dCBibG9ja3MuXG4gICAqIEBwYXJhbSBjcmF3bElkIENyYXdsIGpvYiBpZC5cbiAgICovXG4gIGFzeW5jIGdldENyYXdsRXJyb3JzKGNyYXdsSWQpIHtcbiAgICByZXR1cm4gZ2V0Q3Jhd2xFcnJvcnModGhpcy5odHRwLCBjcmF3bElkKTtcbiAgfVxuICAvKipcbiAgICogTGlzdCBhY3RpdmUgY3Jhd2xzIGZvciB0aGUgYXV0aGVudGljYXRlZCB0ZWFtLlxuICAgKi9cbiAgYXN5bmMgZ2V0QWN0aXZlQ3Jhd2xzKCkge1xuICAgIHJldHVybiBnZXRBY3RpdmVDcmF3bHModGhpcy5odHRwKTtcbiAgfVxuICAvKipcbiAgICogUHJldmlldyBub3JtYWxpemVkIGNyYXdsIHBhcmFtZXRlcnMgcHJvZHVjZWQgYnkgYSBuYXR1cmFsLWxhbmd1YWdlIHByb21wdC5cbiAgICogQHBhcmFtIHVybCBSb290IFVSTC5cbiAgICogQHBhcmFtIHByb21wdCBOYXR1cmFsLWxhbmd1YWdlIGluc3RydWN0aW9uLlxuICAgKi9cbiAgYXN5bmMgY3Jhd2xQYXJhbXNQcmV2aWV3KHVybCwgcHJvbXB0KSB7XG4gICAgcmV0dXJuIGNyYXdsUGFyYW1zUHJldmlldyh0aGlzLmh0dHAsIHVybCwgcHJvbXB0KTtcbiAgfVxuICAvLyBCYXRjaFxuICAvKipcbiAgICogU3RhcnQgYSBiYXRjaCBzY3JhcGUgam9iIGZvciBtdWx0aXBsZSBVUkxzIChhc3luYykuXG4gICAqIEBwYXJhbSB1cmxzIFVSTHMgdG8gc2NyYXBlLlxuICAgKiBAcGFyYW0gb3B0cyBCYXRjaCBvcHRpb25zIChzY3JhcGUgb3B0aW9ucywgd2ViaG9vaywgY29uY3VycmVuY3ksIGlkZW1wb3RlbmN5IGtleSwgZXRjLikuXG4gICAqIEByZXR1cm5zIEpvYiBpZCBhbmQgdXJsLlxuICAgKi9cbiAgYXN5bmMgc3RhcnRCYXRjaFNjcmFwZSh1cmxzLCBvcHRzKSB7XG4gICAgcmV0dXJuIHN0YXJ0QmF0Y2hTY3JhcGUodGhpcy5odHRwLCB1cmxzLCBvcHRzKTtcbiAgfVxuICAvKipcbiAgICogR2V0IHRoZSBzdGF0dXMgYW5kIHBhcnRpYWwgZGF0YSBvZiBhIGJhdGNoIHNjcmFwZSBqb2IuXG4gICAqIEBwYXJhbSBqb2JJZCBCYXRjaCBqb2IgaWQuXG4gICAqL1xuICBhc3luYyBnZXRCYXRjaFNjcmFwZVN0YXR1cyhqb2JJZCwgcGFnaW5hdGlvbikge1xuICAgIHJldHVybiBnZXRCYXRjaFNjcmFwZVN0YXR1cyh0aGlzLmh0dHAsIGpvYklkLCBwYWdpbmF0aW9uKTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmUgYmF0Y2ggc2NyYXBlIGVycm9ycyBhbmQgcm9ib3RzLnR4dCBibG9ja3MuXG4gICAqIEBwYXJhbSBqb2JJZCBCYXRjaCBqb2IgaWQuXG4gICAqL1xuICBhc3luYyBnZXRCYXRjaFNjcmFwZUVycm9ycyhqb2JJZCkge1xuICAgIHJldHVybiBnZXRCYXRjaFNjcmFwZUVycm9ycyh0aGlzLmh0dHAsIGpvYklkKTtcbiAgfVxuICAvKipcbiAgICogQ2FuY2VsIGEgYmF0Y2ggc2NyYXBlIGpvYi5cbiAgICogQHBhcmFtIGpvYklkIEJhdGNoIGpvYiBpZC5cbiAgICogQHJldHVybnMgVHJ1ZSBpZiBjYW5jZWxsZWQuXG4gICAqL1xuICBhc3luYyBjYW5jZWxCYXRjaFNjcmFwZShqb2JJZCkge1xuICAgIHJldHVybiBjYW5jZWxCYXRjaFNjcmFwZSh0aGlzLmh0dHAsIGpvYklkKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2Ugd2FpdGVyOiBzdGFydCBhIGJhdGNoIHNjcmFwZSBhbmQgcG9sbCB1bnRpbCBpdCBmaW5pc2hlcy5cbiAgICogQHBhcmFtIHVybHMgVVJMcyB0byBzY3JhcGUuXG4gICAqIEBwYXJhbSBvcHRzIEJhdGNoIG9wdGlvbnMgcGx1cyB3YWl0ZXIgY29udHJvbHMgKHBvbGxJbnRlcnZhbCwgdGltZW91dCBzZWNvbmRzKS5cbiAgICogQHJldHVybnMgRmluYWwgam9iIHNuYXBzaG90LlxuICAgKi9cbiAgYXN5bmMgYmF0Y2hTY3JhcGUodXJscywgb3B0cykge1xuICAgIHJldHVybiBiYXRjaFNjcmFwZSh0aGlzLmh0dHAsIHVybHMsIG9wdHMpO1xuICB9XG4gIC8vIEV4dHJhY3RcbiAgLyoqXG4gICAqIFN0YXJ0IGFuIGV4dHJhY3Qgam9iIChhc3luYykuXG4gICAqIEBwYXJhbSBhcmdzIEV4dHJhY3Rpb24gcmVxdWVzdCAodXJscywgc2NoZW1hIG9yIHByb21wdCwgZmxhZ3MpLlxuICAgKiBAcmV0dXJucyBKb2IgaWQgb3IgcHJvY2Vzc2luZyBzdGF0ZS5cbiAgICovXG4gIGFzeW5jIHN0YXJ0RXh0cmFjdChhcmdzKSB7XG4gICAgcmV0dXJuIHN0YXJ0RXh0cmFjdCh0aGlzLmh0dHAsIGFyZ3MpO1xuICB9XG4gIC8qKlxuICAgKiBHZXQgZXh0cmFjdCBqb2Igc3RhdHVzL2RhdGEuXG4gICAqIEBwYXJhbSBqb2JJZCBFeHRyYWN0IGpvYiBpZC5cbiAgICovXG4gIGFzeW5jIGdldEV4dHJhY3RTdGF0dXMoam9iSWQpIHtcbiAgICByZXR1cm4gZ2V0RXh0cmFjdFN0YXR1cyh0aGlzLmh0dHAsIGpvYklkKTtcbiAgfVxuICAvKipcbiAgICogQ29udmVuaWVuY2Ugd2FpdGVyOiBzdGFydCBhbiBleHRyYWN0IGFuZCBwb2xsIHVudGlsIGl0IGZpbmlzaGVzLlxuICAgKiBAcGFyYW0gYXJncyBFeHRyYWN0aW9uIHJlcXVlc3QgcGx1cyB3YWl0ZXIgY29udHJvbHMgKHBvbGxJbnRlcnZhbCwgdGltZW91dCBzZWNvbmRzKS5cbiAgICogQHJldHVybnMgRmluYWwgZXh0cmFjdCByZXNwb25zZS5cbiAgICovXG4gIGFzeW5jIGV4dHJhY3QoYXJncykge1xuICAgIHJldHVybiBleHRyYWN0KHRoaXMuaHR0cCwgYXJncyk7XG4gIH1cbiAgLy8gVXNhZ2VcbiAgLyoqIEN1cnJlbnQgY29uY3VycmVuY3kgdXNhZ2UuICovXG4gIGFzeW5jIGdldENvbmN1cnJlbmN5KCkge1xuICAgIHJldHVybiBnZXRDb25jdXJyZW5jeSh0aGlzLmh0dHApO1xuICB9XG4gIC8qKiBDdXJyZW50IGNyZWRpdCB1c2FnZS4gKi9cbiAgYXN5bmMgZ2V0Q3JlZGl0VXNhZ2UoKSB7XG4gICAgcmV0dXJuIGdldENyZWRpdFVzYWdlKHRoaXMuaHR0cCk7XG4gIH1cbiAgLyoqIFJlY2VudCB0b2tlbiB1c2FnZS4gKi9cbiAgYXN5bmMgZ2V0VG9rZW5Vc2FnZSgpIHtcbiAgICByZXR1cm4gZ2V0VG9rZW5Vc2FnZSh0aGlzLmh0dHApO1xuICB9XG4gIC8qKiBIaXN0b3JpY2FsIGNyZWRpdCB1c2FnZSBieSBtb250aDsgc2V0IGJ5QXBpS2V5IHRvIHRydWUgdG8gYnJlYWsgZG93biBieSBBUEkga2V5LiAqL1xuICBhc3luYyBnZXRDcmVkaXRVc2FnZUhpc3RvcmljYWwoYnlBcGlLZXkpIHtcbiAgICByZXR1cm4gZ2V0Q3JlZGl0VXNhZ2VIaXN0b3JpY2FsKHRoaXMuaHR0cCwgYnlBcGlLZXkpO1xuICB9XG4gIC8qKiBIaXN0b3JpY2FsIHRva2VuIHVzYWdlIGJ5IG1vbnRoOyBzZXQgYnlBcGlLZXkgdG8gdHJ1ZSB0byBicmVhayBkb3duIGJ5IEFQSSBrZXkuICovXG4gIGFzeW5jIGdldFRva2VuVXNhZ2VIaXN0b3JpY2FsKGJ5QXBpS2V5KSB7XG4gICAgcmV0dXJuIGdldFRva2VuVXNhZ2VIaXN0b3JpY2FsKHRoaXMuaHR0cCwgYnlBcGlLZXkpO1xuICB9XG4gIC8qKiBNZXRyaWNzIGFib3V0IHRoZSB0ZWFtJ3Mgc2NyYXBlIHF1ZXVlLiAqL1xuICBhc3luYyBnZXRRdWV1ZVN0YXR1cygpIHtcbiAgICByZXR1cm4gZ2V0UXVldWVTdGF0dXModGhpcy5odHRwKTtcbiAgfVxuICAvLyBXYXRjaGVyXG4gIC8qKlxuICAgKiBDcmVhdGUgYSB3YXRjaGVyIGZvciBhIGNyYXdsIG9yIGJhdGNoIGpvYi4gRW1pdHM6IGBkb2N1bWVudGAsIGBzbmFwc2hvdGAsIGBkb25lYCwgYGVycm9yYC5cbiAgICogQHBhcmFtIGpvYklkIEpvYiBpZC5cbiAgICogQHBhcmFtIG9wdHMgV2F0Y2hlciBvcHRpb25zIChraW5kLCBwb2xsSW50ZXJ2YWwsIHRpbWVvdXQgc2Vjb25kcykuXG4gICAqL1xuICB3YXRjaGVyKGpvYklkLCBvcHRzID0ge30pIHtcbiAgICByZXR1cm4gbmV3IFdhdGNoZXIodGhpcy5odHRwLCBqb2JJZCwgb3B0cyk7XG4gIH1cbn07XG5cbi8vIHNyYy92MS9pbmRleC50c1xuaW1wb3J0IGF4aW9zMiwgeyBBeGlvc0Vycm9yIH0gZnJvbSBcImF4aW9zXCI7XG5pbXBvcnQgXCJ6b2RcIjtcbmltcG9ydCB7IHpvZFRvSnNvblNjaGVtYSBhcyB6b2RUb0pzb25TY2hlbWEzIH0gZnJvbSBcInpvZC10by1qc29uLXNjaGVtYVwiO1xuXG4vLyBub2RlX21vZHVsZXMvdHlwZXNjcmlwdC1ldmVudC10YXJnZXQvZGlzdC9pbmRleC5tanNcbnZhciBlID0gY2xhc3MgZXh0ZW5kcyBFdmVudFRhcmdldCB7XG4gIGRpc3BhdGNoVHlwZWRFdmVudChzLCB0KSB7XG4gICAgcmV0dXJuIHN1cGVyLmRpc3BhdGNoRXZlbnQodCk7XG4gIH1cbn07XG5cbi8vIHNyYy92MS9pbmRleC50c1xudmFyIEZpcmVjcmF3bEVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIHN0YXR1c0NvZGU7XG4gIGRldGFpbHM7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1c0NvZGUsIGRldGFpbHMpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gIH1cbn07XG52YXIgRmlyZWNyYXdsQXBwID0gY2xhc3Mge1xuICBhcGlLZXk7XG4gIGFwaVVybDtcbiAgdmVyc2lvbiA9IFwiMS4yNS4xXCI7XG4gIGlzQ2xvdWRTZXJ2aWNlKHVybCkge1xuICAgIHJldHVybiB1cmwuaW5jbHVkZXMoXCJhcGkuZmlyZWNyYXdsLmRldlwiKTtcbiAgfVxuICBhc3luYyBnZXRWZXJzaW9uKCkge1xuICAgIHRyeSB7XG4gICAgICBpZiAodHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgcHJvY2Vzcy5lbnYgJiYgcHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfdmVyc2lvbikge1xuICAgICAgICByZXR1cm4gcHJvY2Vzcy5lbnYubnBtX3BhY2thZ2VfdmVyc2lvbjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhY2thZ2VKc29uID0gYXdhaXQgaW1wb3J0KFwiLi9wYWNrYWdlLVNZS0NNNUpULmpzXCIpO1xuICAgICAgcmV0dXJuIHBhY2thZ2VKc29uLmRlZmF1bHQudmVyc2lvbjtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc3QgaXNUZXN0ID0gdHlwZW9mIHByb2Nlc3MgIT09IFwidW5kZWZpbmVkXCIgJiYgKHByb2Nlc3MuZW52LkpFU1RfV09SS0VSX0lEICE9IG51bGwgfHwgZmFsc2UpO1xuICAgICAgaWYgKCFpc1Rlc3QpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yIGdldHRpbmcgdmVyc2lvbjpcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFwiMS4yNS4xXCI7XG4gICAgfVxuICB9XG4gIGFzeW5jIGluaXQoKSB7XG4gICAgdGhpcy52ZXJzaW9uID0gYXdhaXQgdGhpcy5nZXRWZXJzaW9uKCk7XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYWxpemVzIGEgbmV3IGluc3RhbmNlIG9mIHRoZSBGaXJlY3Jhd2xBcHAgY2xhc3MuXG4gICAqIEBwYXJhbSBjb25maWcgLSBDb25maWd1cmF0aW9uIG9wdGlvbnMgZm9yIHRoZSBGaXJlY3Jhd2xBcHAgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7IGFwaUtleSA9IG51bGwsIGFwaVVybCA9IG51bGwgfSkge1xuICAgIGNvbnN0IGJhc2VVcmwgPSBhcGlVcmwgfHwgXCJodHRwczovL2FwaS5maXJlY3Jhd2wuZGV2XCI7XG4gICAgaWYgKHRoaXMuaXNDbG91ZFNlcnZpY2UoYmFzZVVybCkgJiYgdHlwZW9mIGFwaUtleSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiTm8gQVBJIGtleSBwcm92aWRlZFwiLCA0MDEpO1xuICAgIH1cbiAgICB0aGlzLmFwaUtleSA9IGFwaUtleSB8fCBcIlwiO1xuICAgIHRoaXMuYXBpVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuICAvKipcbiAgICogU2NyYXBlcyBhIFVSTCB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gc2NyYXBlLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgc2NyYXBlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBzY3JhcGUgb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgc2NyYXBlVXJsKHVybCwgcGFyYW1zKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3RoaXMuYXBpS2V5fWBcbiAgICB9O1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJsLCAuLi5wYXJhbXMsIG9yaWdpbjogdHlwZW9mIHBhcmFtcy5vcmlnaW4gPT09IFwic3RyaW5nXCIgJiYgcGFyYW1zLm9yaWdpbi5pbmNsdWRlcyhcIm1jcFwiKSA/IHBhcmFtcy5vcmlnaW4gOiBganMtc2RrQCR7dGhpcy52ZXJzaW9ufWAgfTtcbiAgICBpZiAoanNvbkRhdGE/LmV4dHJhY3Q/LnNjaGVtYSkge1xuICAgICAgbGV0IHNjaGVtYSA9IGpzb25EYXRhLmV4dHJhY3Quc2NoZW1hO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2NoZW1hID0gem9kVG9Kc29uU2NoZW1hMyhzY2hlbWEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGpzb25EYXRhID0ge1xuICAgICAgICAuLi5qc29uRGF0YSxcbiAgICAgICAgZXh0cmFjdDoge1xuICAgICAgICAgIC4uLmpzb25EYXRhLmV4dHJhY3QsXG4gICAgICAgICAgc2NoZW1hXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChqc29uRGF0YT8uanNvbk9wdGlvbnM/LnNjaGVtYSkge1xuICAgICAgbGV0IHNjaGVtYSA9IGpzb25EYXRhLmpzb25PcHRpb25zLnNjaGVtYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYTMoc2NoZW1hKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgICBqc29uRGF0YSA9IHtcbiAgICAgICAgLi4uanNvbkRhdGEsXG4gICAgICAgIGpzb25PcHRpb25zOiB7XG4gICAgICAgICAgLi4uanNvbkRhdGEuanNvbk9wdGlvbnMsXG4gICAgICAgICAgc2NoZW1hXG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zMi5wb3N0KFxuICAgICAgICB0aGlzLmFwaVVybCArIGAvdjEvc2NyYXBlYCxcbiAgICAgICAganNvbkRhdGEsXG4gICAgICAgIHsgaGVhZGVycywgdGltZW91dDogcGFyYW1zPy50aW1lb3V0ICE9PSB2b2lkIDAgPyBwYXJhbXMudGltZW91dCArIDVlMyA6IHZvaWQgMCB9XG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChyZXNwb25zZURhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgd2FybmluZzogcmVzcG9uc2VEYXRhLndhcm5pbmcsXG4gICAgICAgICAgICBlcnJvcjogcmVzcG9uc2VEYXRhLmVycm9yLFxuICAgICAgICAgICAgLi4ucmVzcG9uc2VEYXRhLmRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgRmFpbGVkIHRvIHNjcmFwZSBVUkwuIEVycm9yOiAke3Jlc3BvbnNlRGF0YS5lcnJvcn1gLCByZXNwb25zZS5zdGF0dXMpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcInNjcmFwZSBVUkxcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMuaGFuZGxlRXJyb3IoZXJyb3IucmVzcG9uc2UsIFwic2NyYXBlIFVSTFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBTZWFyY2hlcyB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSSBhbmQgb3B0aW9uYWxseSBzY3JhcGVzIHRoZSByZXN1bHRzLlxuICAgKiBAcGFyYW0gcXVlcnkgLSBUaGUgc2VhcmNoIHF1ZXJ5IHN0cmluZy5cbiAgICogQHBhcmFtIHBhcmFtcyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzZWFyY2ggcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIHNlYXJjaCBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBzZWFyY2gocXVlcnksIHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgIEF1dGhvcml6YXRpb246IGBCZWFyZXIgJHt0aGlzLmFwaUtleX1gXG4gICAgfTtcbiAgICBsZXQganNvbkRhdGEgPSB7XG4gICAgICBxdWVyeSxcbiAgICAgIGxpbWl0OiBwYXJhbXM/LmxpbWl0ID8/IDUsXG4gICAgICB0YnM6IHBhcmFtcz8udGJzLFxuICAgICAgZmlsdGVyOiBwYXJhbXM/LmZpbHRlcixcbiAgICAgIGxhbmc6IHBhcmFtcz8ubGFuZyA/PyBcImVuXCIsXG4gICAgICBjb3VudHJ5OiBwYXJhbXM/LmNvdW50cnkgPz8gXCJ1c1wiLFxuICAgICAgbG9jYXRpb246IHBhcmFtcz8ubG9jYXRpb24sXG4gICAgICBvcmlnaW46IHR5cGVvZiBwYXJhbXMub3JpZ2luID09PSBcInN0cmluZ1wiICYmIHBhcmFtcy5vcmlnaW4uaW5jbHVkZXMoXCJtY3BcIikgPyBwYXJhbXMub3JpZ2luIDogYGpzLXNka0Ake3RoaXMudmVyc2lvbn1gLFxuICAgICAgdGltZW91dDogcGFyYW1zPy50aW1lb3V0ID8/IDZlNCxcbiAgICAgIHNjcmFwZU9wdGlvbnM6IHBhcmFtcz8uc2NyYXBlT3B0aW9ucyA/PyB7IGZvcm1hdHM6IFtdIH1cbiAgICB9O1xuICAgIGlmIChqc29uRGF0YT8uc2NyYXBlT3B0aW9ucz8uZXh0cmFjdD8uc2NoZW1hKSB7XG4gICAgICBsZXQgc2NoZW1hID0ganNvbkRhdGEuc2NyYXBlT3B0aW9ucy5leHRyYWN0LnNjaGVtYTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYTMoc2NoZW1hKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB9XG4gICAgICBqc29uRGF0YSA9IHtcbiAgICAgICAgLi4uanNvbkRhdGEsXG4gICAgICAgIHNjcmFwZU9wdGlvbnM6IHtcbiAgICAgICAgICAuLi5qc29uRGF0YS5zY3JhcGVPcHRpb25zLFxuICAgICAgICAgIGV4dHJhY3Q6IHtcbiAgICAgICAgICAgIC4uLmpzb25EYXRhLnNjcmFwZU9wdGlvbnMuZXh0cmFjdCxcbiAgICAgICAgICAgIHNjaGVtYVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL3NlYXJjaGAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHJlc3BvbnNlLmRhdGE7XG4gICAgICAgIGlmIChyZXNwb25zZURhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLmRhdGEsXG4gICAgICAgICAgICB3YXJuaW5nOiByZXNwb25zZURhdGEud2FybmluZ1xuICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBGYWlsZWQgdG8gc2VhcmNoLiBFcnJvcjogJHtyZXNwb25zZURhdGEuZXJyb3J9YCwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzZWFyY2hcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiwgZGF0YTogW10gfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgY3Jhd2wgam9iIGZvciBhIFVSTCB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gY3Jhd2wuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmF3bCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gcG9sbEludGVydmFsIC0gVGltZSBpbiBzZWNvbmRzIGZvciBqb2Igc3RhdHVzIGNoZWNrcy5cbiAgICogQHBhcmFtIGlkZW1wb3RlbmN5S2V5IC0gT3B0aW9uYWwgaWRlbXBvdGVuY3kga2V5IGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIGNyYXdsIG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIGNyYXdsVXJsKHVybCwgcGFyYW1zLCBwb2xsSW50ZXJ2YWwgPSAyLCBpZGVtcG90ZW5jeUtleSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKGlkZW1wb3RlbmN5S2V5KTtcbiAgICBsZXQganNvbkRhdGEgPSB7IHVybCwgLi4ucGFyYW1zLCBvcmlnaW46IHR5cGVvZiBwYXJhbXMub3JpZ2luID09PSBcInN0cmluZ1wiICYmIHBhcmFtcy5vcmlnaW4uaW5jbHVkZXMoXCJtY3BcIikgPyBwYXJhbXMub3JpZ2luIDogYGpzLXNka0Ake3RoaXMudmVyc2lvbn1gIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL2NyYXdsYCxcbiAgICAgICAganNvbkRhdGEsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY29uc3QgaWQgPSByZXNwb25zZS5kYXRhLmlkO1xuICAgICAgICByZXR1cm4gdGhpcy5tb25pdG9ySm9iU3RhdHVzKGlkLCBoZWFkZXJzLCBwb2xsSW50ZXJ2YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzdGFydCBjcmF3bCBqb2JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIGFzeW5jIGFzeW5jQ3Jhd2xVcmwodXJsLCBwYXJhbXMsIGlkZW1wb3RlbmN5S2V5KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoaWRlbXBvdGVuY3lLZXkpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJsLCAuLi5wYXJhbXMsIG9yaWdpbjogdHlwZW9mIHBhcmFtcy5vcmlnaW4gPT09IFwic3RyaW5nXCIgJiYgcGFyYW1zLm9yaWdpbi5pbmNsdWRlcyhcIm1jcFwiKSA/IHBhcmFtcy5vcmlnaW4gOiBganMtc2RrQCR7dGhpcy52ZXJzaW9ufWAgfTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLnBvc3RSZXF1ZXN0KFxuICAgICAgICB0aGlzLmFwaVVybCArIGAvdjEvY3Jhd2xgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgY3Jhd2wgam9iXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3J9ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIn1gLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgYSBjcmF3bCBqb2IgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gZ2V0QWxsRGF0YSAtIFBhZ2luYXRlIHRocm91Z2ggYWxsIHRoZSBwYWdlcyBvZiBkb2N1bWVudHMsIHJldHVybmluZyB0aGUgZnVsbCBsaXN0IG9mIGFsbCBkb2N1bWVudHMuIChkZWZhdWx0OiBgZmFsc2VgKVxuICAgKiBAcGFyYW0gbmV4dFVSTCAtIFRoZSBgbmV4dGAgVVJMIGZyb20gdGhlIHByZXZpb3VzIGNyYXdsIHN0YXR1cy4gT25seSByZXF1aXJlZCBpZiB5b3UncmUgbm90IG1hbnVhbGx5IGluY3JlYXNpbmcgYHNraXBgLiBPbmx5IHVzZWQgd2hlbiBgZ2V0QWxsRGF0YSA9IGZhbHNlYC5cbiAgICogQHBhcmFtIHNraXAgLSBIb3cgbWFueSBlbnRyaWVzIHRvIHNraXAgdG8gcGFnaW5hdGUuIE9ubHkgcmVxdWlyZWQgaWYgeW91J3JlIG5vdCBwcm92aWRpbmcgYG5leHRVUkxgLiBPbmx5IHVzZWQgd2hlbiBgZ2V0QWxsRGF0YSA9IGZhbHNlYC5cbiAgICogQHBhcmFtIGxpbWl0IC0gSG93IG1hbnkgZW50cmllcyB0byByZXR1cm4uIE9ubHkgdXNlZCB3aGVuIGBnZXRBbGxEYXRhID0gZmFsc2VgLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgY29udGFpbmluZyB0aGUgam9iIHN0YXR1cy5cbiAgICovXG4gIGFzeW5jIGNoZWNrQ3Jhd2xTdGF0dXMoaWQsIGdldEFsbERhdGEgPSBmYWxzZSwgbmV4dFVSTCwgc2tpcCwgbGltaXQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJObyBjcmF3bCBJRCBwcm92aWRlZFwiLCA0MDApO1xuICAgIH1cbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIGNvbnN0IHRhcmdldFVSTCA9IG5ldyBVUkwobmV4dFVSTCA/PyBgJHt0aGlzLmFwaVVybH0vdjEvY3Jhd2wvJHtpZH1gKTtcbiAgICBpZiAoc2tpcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0YXJnZXRVUkwuc2VhcmNoUGFyYW1zLnNldChcInNraXBcIiwgc2tpcC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKGxpbWl0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFVSTC5zZWFyY2hQYXJhbXMuc2V0KFwibGltaXRcIiwgbGltaXQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgdGFyZ2V0VVJMLmhyZWYsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgbGV0IGFsbERhdGEgPSByZXNwb25zZS5kYXRhLmRhdGE7XG4gICAgICAgIGlmIChnZXRBbGxEYXRhICYmIHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgbGV0IHN0YXR1c0RhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBzdGF0dXNEYXRhKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHN0YXR1c0RhdGEuZGF0YTtcbiAgICAgICAgICAgIHdoaWxlICh0eXBlb2Ygc3RhdHVzRGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcIm5leHRcIiBpbiBzdGF0dXNEYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXR1c0RhdGEgPSAoYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KHN0YXR1c0RhdGEubmV4dCwgaGVhZGVycykpLmRhdGE7XG4gICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChzdGF0dXNEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsRGF0YSA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwID0ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHJlc3BvbnNlLmRhdGEuc3VjY2VzcyxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLmRhdGEuc3RhdHVzLFxuICAgICAgICAgIHRvdGFsOiByZXNwb25zZS5kYXRhLnRvdGFsLFxuICAgICAgICAgIGNvbXBsZXRlZDogcmVzcG9uc2UuZGF0YS5jb21wbGV0ZWQsXG4gICAgICAgICAgY3JlZGl0c1VzZWQ6IHJlc3BvbnNlLmRhdGEuY3JlZGl0c1VzZWQsXG4gICAgICAgICAgbmV4dDogZ2V0QWxsRGF0YSA/IHZvaWQgMCA6IHJlc3BvbnNlLmRhdGEubmV4dCxcbiAgICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKHJlc3BvbnNlLmRhdGEuZXhwaXJlc0F0KSxcbiAgICAgICAgICBkYXRhOiBhbGxEYXRhXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmVzcG9uc2UuZGF0YS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEuZXJyb3IpIHtcbiAgICAgICAgICByZXNwID0ge1xuICAgICAgICAgICAgLi4ucmVzcCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IHJlc3BvbnNlLmRhdGEuZXJyb3JcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHQpIHtcbiAgICAgICAgICByZXNwLm5leHQgPSByZXNwb25zZS5kYXRhLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIGNyYXdsIHN0YXR1c1wiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogUmV0dXJucyBpbmZvcm1hdGlvbiBhYm91dCBjcmF3bCBlcnJvcnMuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBJbmZvcm1hdGlvbiBhYm91dCBjcmF3bCBlcnJvcnMuXG4gICAqL1xuICBhc3luYyBjaGVja0NyYXdsRXJyb3JzKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmRlbGV0ZVJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9jcmF3bC8ke2lkfS9lcnJvcnNgLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJjaGVjayBjcmF3bCBlcnJvcnNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIENhbmNlbHMgYSBjcmF3bCBqb2IgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgY3Jhd2wgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgY2FuY2VsIGNyYXdsIG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIGNhbmNlbENyYXdsKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmRlbGV0ZVJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9jcmF3bC8ke2lkfWAsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNhbmNlbCBjcmF3bCBqb2JcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGNyYXdsIGpvYiBhbmQgcmV0dXJucyBhIENyYXdsV2F0Y2hlciB0byBtb25pdG9yIHRoZSBqb2IgdmlhIFdlYlNvY2tldC5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gY3Jhd2wuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBjcmF3bCByZXF1ZXN0LlxuICAgKiBAcGFyYW0gaWRlbXBvdGVuY3lLZXkgLSBPcHRpb25hbCBpZGVtcG90ZW5jeSBrZXkgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIENyYXdsV2F0Y2hlciBpbnN0YW5jZSB0byBtb25pdG9yIHRoZSBjcmF3bCBqb2IuXG4gICAqL1xuICBhc3luYyBjcmF3bFVybEFuZFdhdGNoKHVybCwgcGFyYW1zLCBpZGVtcG90ZW5jeUtleSkge1xuICAgIGNvbnN0IGNyYXdsMiA9IGF3YWl0IHRoaXMuYXN5bmNDcmF3bFVybCh1cmwsIHBhcmFtcywgaWRlbXBvdGVuY3lLZXkpO1xuICAgIGlmIChjcmF3bDIuc3VjY2VzcyAmJiBjcmF3bDIuaWQpIHtcbiAgICAgIGNvbnN0IGlkID0gY3Jhd2wyLmlkO1xuICAgICAgcmV0dXJuIG5ldyBDcmF3bFdhdGNoZXIoaWQsIHRoaXMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJDcmF3bCBqb2IgZmFpbGVkIHRvIHN0YXJ0XCIsIDQwMCk7XG4gIH1cbiAgLyoqXG4gICAqIE1hcHMgYSBVUkwgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSB1cmwgLSBUaGUgVVJMIHRvIG1hcC5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIG1hcCByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgbWFwIG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIG1hcFVybCh1cmwsIHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgbGV0IGpzb25EYXRhID0geyB1cmwsIC4uLnBhcmFtcywgb3JpZ2luOiB0eXBlb2YgcGFyYW1zLm9yaWdpbiA9PT0gXCJzdHJpbmdcIiAmJiBwYXJhbXMub3JpZ2luLmluY2x1ZGVzKFwibWNwXCIpID8gcGFyYW1zLm9yaWdpbiA6IGBqcy1zZGtAJHt0aGlzLnZlcnNpb259YCB9O1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYXBpVXJsICsgYC92MS9tYXBgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwibWFwXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYSBiYXRjaCBzY3JhcGUgam9iIGZvciBtdWx0aXBsZSBVUkxzIHVzaW5nIHRoZSBGaXJlY3Jhd2wgQVBJLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTHMgdG8gc2NyYXBlLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gQWRkaXRpb25hbCBwYXJhbWV0ZXJzIGZvciB0aGUgc2NyYXBlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBwb2xsSW50ZXJ2YWwgLSBUaW1lIGluIHNlY29uZHMgZm9yIGpvYiBzdGF0dXMgY2hlY2tzLlxuICAgKiBAcGFyYW0gaWRlbXBvdGVuY3lLZXkgLSBPcHRpb25hbCBpZGVtcG90ZW5jeSBrZXkgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gd2ViaG9vayAtIE9wdGlvbmFsIHdlYmhvb2sgZm9yIHRoZSBiYXRjaCBzY3JhcGUuXG4gICAqIEBwYXJhbSBpZ25vcmVJbnZhbGlkVVJMcyAtIE9wdGlvbmFsIGZsYWcgdG8gaWdub3JlIGludmFsaWQgVVJMcy5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIGNyYXdsIG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIGJhdGNoU2NyYXBlVXJscyh1cmxzLCBwYXJhbXMsIHBvbGxJbnRlcnZhbCA9IDIsIGlkZW1wb3RlbmN5S2V5LCB3ZWJob29rLCBpZ25vcmVJbnZhbGlkVVJMcywgbWF4Q29uY3VycmVuY3kpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycyhpZGVtcG90ZW5jeUtleSk7XG4gICAgbGV0IGpzb25EYXRhID0geyB1cmxzLCB3ZWJob29rLCBpZ25vcmVJbnZhbGlkVVJMcywgbWF4Q29uY3VycmVuY3ksIC4uLnBhcmFtcywgb3JpZ2luOiB0eXBlb2YgcGFyYW1zLm9yaWdpbiA9PT0gXCJzdHJpbmdcIiAmJiBwYXJhbXMub3JpZ2luLmluY2x1ZGVzKFwibWNwXCIpID8gcGFyYW1zLm9yaWdpbiA6IGBqcy1zZGtAJHt0aGlzLnZlcnNpb259YCB9O1xuICAgIGlmIChqc29uRGF0YT8uZXh0cmFjdD8uc2NoZW1hKSB7XG4gICAgICBsZXQgc2NoZW1hID0ganNvbkRhdGEuZXh0cmFjdC5zY2hlbWE7XG4gICAgICB0cnkge1xuICAgICAgICBzY2hlbWEgPSB6b2RUb0pzb25TY2hlbWEzKHNjaGVtYSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgfVxuICAgICAganNvbkRhdGEgPSB7XG4gICAgICAgIC4uLmpzb25EYXRhLFxuICAgICAgICBleHRyYWN0OiB7XG4gICAgICAgICAgLi4uanNvbkRhdGEuZXh0cmFjdCxcbiAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKGpzb25EYXRhPy5qc29uT3B0aW9ucz8uc2NoZW1hKSB7XG4gICAgICBsZXQgc2NoZW1hID0ganNvbkRhdGEuanNvbk9wdGlvbnMuc2NoZW1hO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2NoZW1hID0gem9kVG9Kc29uU2NoZW1hMyhzY2hlbWEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGpzb25EYXRhID0ge1xuICAgICAgICAuLi5qc29uRGF0YSxcbiAgICAgICAganNvbk9wdGlvbnM6IHtcbiAgICAgICAgICAuLi5qc29uRGF0YS5qc29uT3B0aW9ucyxcbiAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL2JhdGNoL3NjcmFwZWAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIGNvbnN0IGlkID0gcmVzcG9uc2UuZGF0YS5pZDtcbiAgICAgICAgcmV0dXJuIHRoaXMubW9uaXRvckpvYlN0YXR1cyhpZCwgaGVhZGVycywgcG9sbEludGVydmFsKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgYmF0Y2ggc2NyYXBlIGpvYlwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgYXN5bmMgYXN5bmNCYXRjaFNjcmFwZVVybHModXJscywgcGFyYW1zLCBpZGVtcG90ZW5jeUtleSwgd2ViaG9vaywgaWdub3JlSW52YWxpZFVSTHMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycyhpZGVtcG90ZW5jeUtleSk7XG4gICAgbGV0IGpzb25EYXRhID0geyB1cmxzLCB3ZWJob29rLCBpZ25vcmVJbnZhbGlkVVJMcywgLi4ucGFyYW1zLCBvcmlnaW46IHR5cGVvZiBwYXJhbXMub3JpZ2luID09PSBcInN0cmluZ1wiICYmIHBhcmFtcy5vcmlnaW4uaW5jbHVkZXMoXCJtY3BcIikgPyBwYXJhbXMub3JpZ2luIDogYGpzLXNka0Ake3RoaXMudmVyc2lvbn1gIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgdGhpcy5hcGlVcmwgKyBgL3YxL2JhdGNoL3NjcmFwZWAsXG4gICAgICAgIGpzb25EYXRhLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJzdGFydCBiYXRjaCBzY3JhcGUgam9iXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3J9ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIn1gLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgYmF0Y2ggc2NyYXBlIGpvYiBhbmQgcmV0dXJucyBhIENyYXdsV2F0Y2hlciB0byBtb25pdG9yIHRoZSBqb2IgdmlhIFdlYlNvY2tldC5cbiAgICogQHBhcmFtIHVybHMgLSBUaGUgVVJMIHRvIHNjcmFwZS5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNjcmFwZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gaWRlbXBvdGVuY3lLZXkgLSBPcHRpb25hbCBpZGVtcG90ZW5jeSBrZXkgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBBIENyYXdsV2F0Y2hlciBpbnN0YW5jZSB0byBtb25pdG9yIHRoZSBjcmF3bCBqb2IuXG4gICAqL1xuICBhc3luYyBiYXRjaFNjcmFwZVVybHNBbmRXYXRjaCh1cmxzLCBwYXJhbXMsIGlkZW1wb3RlbmN5S2V5LCB3ZWJob29rLCBpZ25vcmVJbnZhbGlkVVJMcykge1xuICAgIGNvbnN0IGNyYXdsMiA9IGF3YWl0IHRoaXMuYXN5bmNCYXRjaFNjcmFwZVVybHModXJscywgcGFyYW1zLCBpZGVtcG90ZW5jeUtleSwgd2ViaG9vaywgaWdub3JlSW52YWxpZFVSTHMpO1xuICAgIGlmIChjcmF3bDIuc3VjY2VzcyAmJiBjcmF3bDIuaWQpIHtcbiAgICAgIGNvbnN0IGlkID0gY3Jhd2wyLmlkO1xuICAgICAgcmV0dXJuIG5ldyBDcmF3bFdhdGNoZXIoaWQsIHRoaXMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJCYXRjaCBzY3JhcGUgam9iIGZhaWxlZCB0byBzdGFydFwiLCA0MDApO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgdGhlIHN0YXR1cyBvZiBhIGJhdGNoIHNjcmFwZSBqb2IgdXNpbmcgdGhlIEZpcmVjcmF3bCBBUEkuXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgYmF0Y2ggc2NyYXBlIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGdldEFsbERhdGEgLSBQYWdpbmF0ZSB0aHJvdWdoIGFsbCB0aGUgcGFnZXMgb2YgZG9jdW1lbnRzLCByZXR1cm5pbmcgdGhlIGZ1bGwgbGlzdCBvZiBhbGwgZG9jdW1lbnRzLiAoZGVmYXVsdDogYGZhbHNlYClcbiAgICogQHBhcmFtIG5leHRVUkwgLSBUaGUgYG5leHRgIFVSTCBmcm9tIHRoZSBwcmV2aW91cyBiYXRjaCBzY3JhcGUgc3RhdHVzLiBPbmx5IHJlcXVpcmVkIGlmIHlvdSdyZSBub3QgbWFudWFsbHkgaW5jcmVhc2luZyBgc2tpcGAuIE9ubHkgdXNlZCB3aGVuIGBnZXRBbGxEYXRhID0gZmFsc2VgLlxuICAgKiBAcGFyYW0gc2tpcCAtIEhvdyBtYW55IGVudHJpZXMgdG8gc2tpcCB0byBwYWdpbmF0ZS4gT25seSB1c2VkIHdoZW4gYGdldEFsbERhdGEgPSBmYWxzZWAuXG4gICAqIEBwYXJhbSBsaW1pdCAtIEhvdyBtYW55IGVudHJpZXMgdG8gcmV0dXJuLiBPbmx5IHVzZWQgd2hlbiBgZ2V0QWxsRGF0YSA9IGZhbHNlYC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGpvYiBzdGF0dXMuXG4gICAqL1xuICBhc3luYyBjaGVja0JhdGNoU2NyYXBlU3RhdHVzKGlkLCBnZXRBbGxEYXRhID0gZmFsc2UsIG5leHRVUkwsIHNraXAsIGxpbWl0KSB7XG4gICAgaWYgKCFpZCkge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiTm8gYmF0Y2ggc2NyYXBlIElEIHByb3ZpZGVkXCIsIDQwMCk7XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgY29uc3QgdGFyZ2V0VVJMID0gbmV3IFVSTChuZXh0VVJMID8/IGAke3RoaXMuYXBpVXJsfS92MS9iYXRjaC9zY3JhcGUvJHtpZH1gKTtcbiAgICBpZiAoc2tpcCAhPT0gdm9pZCAwKSB7XG4gICAgICB0YXJnZXRVUkwuc2VhcmNoUGFyYW1zLnNldChcInNraXBcIiwgc2tpcC50b1N0cmluZygpKTtcbiAgICB9XG4gICAgaWYgKGxpbWl0ICE9PSB2b2lkIDApIHtcbiAgICAgIHRhcmdldFVSTC5zZWFyY2hQYXJhbXMuc2V0KFwibGltaXRcIiwgbGltaXQudG9TdHJpbmcoKSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgdGFyZ2V0VVJMLmhyZWYsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgbGV0IGFsbERhdGEgPSByZXNwb25zZS5kYXRhLmRhdGE7XG4gICAgICAgIGlmIChnZXRBbGxEYXRhICYmIHJlc3BvbnNlLmRhdGEuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgbGV0IHN0YXR1c0RhdGEgPSByZXNwb25zZS5kYXRhO1xuICAgICAgICAgIGlmIChcImRhdGFcIiBpbiBzdGF0dXNEYXRhKSB7XG4gICAgICAgICAgICBsZXQgZGF0YSA9IHN0YXR1c0RhdGEuZGF0YTtcbiAgICAgICAgICAgIHdoaWxlICh0eXBlb2Ygc3RhdHVzRGF0YSA9PT0gXCJvYmplY3RcIiAmJiBcIm5leHRcIiBpbiBzdGF0dXNEYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXR1c0RhdGEgPSAoYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KHN0YXR1c0RhdGEubmV4dCwgaGVhZGVycykpLmRhdGE7XG4gICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChzdGF0dXNEYXRhLmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWxsRGF0YSA9IGRhdGE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCByZXNwID0ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHJlc3BvbnNlLmRhdGEuc3VjY2VzcyxcbiAgICAgICAgICBzdGF0dXM6IHJlc3BvbnNlLmRhdGEuc3RhdHVzLFxuICAgICAgICAgIHRvdGFsOiByZXNwb25zZS5kYXRhLnRvdGFsLFxuICAgICAgICAgIGNvbXBsZXRlZDogcmVzcG9uc2UuZGF0YS5jb21wbGV0ZWQsXG4gICAgICAgICAgY3JlZGl0c1VzZWQ6IHJlc3BvbnNlLmRhdGEuY3JlZGl0c1VzZWQsXG4gICAgICAgICAgbmV4dDogZ2V0QWxsRGF0YSA/IHZvaWQgMCA6IHJlc3BvbnNlLmRhdGEubmV4dCxcbiAgICAgICAgICBleHBpcmVzQXQ6IG5ldyBEYXRlKHJlc3BvbnNlLmRhdGEuZXhwaXJlc0F0KSxcbiAgICAgICAgICBkYXRhOiBhbGxEYXRhXG4gICAgICAgIH07XG4gICAgICAgIGlmICghcmVzcG9uc2UuZGF0YS5zdWNjZXNzICYmIHJlc3BvbnNlLmRhdGEuZXJyb3IpIHtcbiAgICAgICAgICByZXNwID0ge1xuICAgICAgICAgICAgLi4ucmVzcCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICAgICAgZXJyb3I6IHJlc3BvbnNlLmRhdGEuZXJyb3JcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNwb25zZS5kYXRhLm5leHQpIHtcbiAgICAgICAgICByZXNwLm5leHQgPSByZXNwb25zZS5kYXRhLm5leHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3A7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIGJhdGNoIHNjcmFwZSBzdGF0dXNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIFJldHVybnMgaW5mb3JtYXRpb24gYWJvdXQgYmF0Y2ggc2NyYXBlIGVycm9ycy5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBiYXRjaCBzY3JhcGUgb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBJbmZvcm1hdGlvbiBhYm91dCBiYXRjaCBzY3JhcGUgZXJyb3JzLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tCYXRjaFNjcmFwZUVycm9ycyhpZCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5kZWxldGVSZXF1ZXN0KFxuICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvYmF0Y2gvc2NyYXBlLyR7aWR9L2Vycm9yc2AsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIGJhdGNoIHNjcmFwZSBlcnJvcnNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEV4dHJhY3RzIGluZm9ybWF0aW9uIGZyb20gVVJMcyB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQ3VycmVudGx5IGluIEJldGEuIEV4cGVjdCBicmVha2luZyBjaGFuZ2VzIG9uIGZ1dHVyZSBtaW5vciB2ZXJzaW9ucy5cbiAgICogQHBhcmFtIHVybHMgLSBUaGUgVVJMcyB0byBleHRyYWN0IGluZm9ybWF0aW9uIGZyb20uIE9wdGlvbmFsIGlmIHVzaW5nIG90aGVyIG1ldGhvZHMgZm9yIGRhdGEgZXh0cmFjdGlvbi5cbiAgICogQHBhcmFtIHBhcmFtcyAtIEFkZGl0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIGV4dHJhY3QgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIGV4dHJhY3Qgb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgZXh0cmFjdCh1cmxzLCBwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJscywgLi4ucGFyYW1zIH07XG4gICAgbGV0IGpzb25TY2hlbWE7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcGFyYW1zPy5zY2hlbWEpIHtcbiAgICAgICAganNvblNjaGVtYSA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAganNvblNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYTMocGFyYW1zLnNjaGVtYSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICBqc29uU2NoZW1hID0gcGFyYW1zLnNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJJbnZhbGlkIHNjaGVtYS4gU2NoZW1hIG11c3QgYmUgZWl0aGVyIGEgdmFsaWQgWm9kIHNjaGVtYSBvciBKU09OIHNjaGVtYSBvYmplY3QuXCIsIDQwMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYXBpVXJsICsgYC92MS9leHRyYWN0YCxcbiAgICAgICAgeyAuLi5qc29uRGF0YSwgc2NoZW1hOiBqc29uU2NoZW1hLCBvcmlnaW46IHR5cGVvZiBwYXJhbXMub3JpZ2luID09PSBcInN0cmluZ1wiICYmIHBhcmFtcy5vcmlnaW4uaW5jbHVkZXMoXCJtY3BcIikgPyBwYXJhbXMub3JpZ2luIDogYGpzLXNka0Ake3RoaXMudmVyc2lvbn1gIH0sXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgY29uc3Qgam9iSWQgPSByZXNwb25zZS5kYXRhLmlkO1xuICAgICAgICBsZXQgZXh0cmFjdFN0YXR1cztcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNvbnN0IHN0YXR1c1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KFxuICAgICAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2V4dHJhY3QvJHtqb2JJZH1gLFxuICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICk7XG4gICAgICAgICAgZXh0cmFjdFN0YXR1cyA9IHN0YXR1c1Jlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgaWYgKGV4dHJhY3RTdGF0dXMuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgICBpZiAoZXh0cmFjdFN0YXR1cy5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBleHRyYWN0U3RhdHVzLmRhdGEsXG4gICAgICAgICAgICAgICAgd2FybmluZzogZXh0cmFjdFN0YXR1cy53YXJuaW5nLFxuICAgICAgICAgICAgICAgIGVycm9yOiBleHRyYWN0U3RhdHVzLmVycm9yLFxuICAgICAgICAgICAgICAgIHNvdXJjZXM6IGV4dHJhY3RTdGF0dXM/LnNvdXJjZXMgfHwgdm9pZCAwXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEZhaWxlZCB0byBleHRyYWN0IGRhdGEuIEVycm9yOiAke2V4dHJhY3RTdGF0dXMuZXJyb3J9YCwgc3RhdHVzUmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGV4dHJhY3RTdGF0dXMuc3RhdHVzID09PSBcImZhaWxlZFwiIHx8IGV4dHJhY3RTdGF0dXMuc3RhdHVzID09PSBcImNhbmNlbGxlZFwiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEV4dHJhY3Qgam9iICR7ZXh0cmFjdFN0YXR1cy5zdGF0dXN9LiBFcnJvcjogJHtleHRyYWN0U3RhdHVzLmVycm9yfWAsIHN0YXR1c1Jlc3BvbnNlLnN0YXR1cyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDFlMykpO1xuICAgICAgICB9IHdoaWxlIChleHRyYWN0U3RhdHVzLnN0YXR1cyAhPT0gXCJjb21wbGV0ZWRcIik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImV4dHJhY3RcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWxzKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBJbml0aWF0ZXMgYW4gYXN5bmNocm9ub3VzIGV4dHJhY3Qgam9iIGZvciBhIFVSTCB1c2luZyB0aGUgRmlyZWNyYXdsIEFQSS5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gZXh0cmFjdCBkYXRhIGZyb20uXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBBZGRpdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBleHRyYWN0IHJlcXVlc3QuXG4gICAqIEBwYXJhbSBpZGVtcG90ZW5jeUtleSAtIE9wdGlvbmFsIGlkZW1wb3RlbmN5IGtleSBmb3IgdGhlIHJlcXVlc3QuXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBmcm9tIHRoZSBleHRyYWN0IG9wZXJhdGlvbi5cbiAgICovXG4gIGFzeW5jIGFzeW5jRXh0cmFjdCh1cmxzLCBwYXJhbXMsIGlkZW1wb3RlbmN5S2V5KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoaWRlbXBvdGVuY3lLZXkpO1xuICAgIGxldCBqc29uRGF0YSA9IHsgdXJscywgLi4ucGFyYW1zIH07XG4gICAgbGV0IGpzb25TY2hlbWE7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghcGFyYW1zPy5zY2hlbWEpIHtcbiAgICAgICAganNvblNjaGVtYSA9IHZvaWQgMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAganNvblNjaGVtYSA9IHpvZFRvSnNvblNjaGVtYTMocGFyYW1zLnNjaGVtYSk7XG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICBqc29uU2NoZW1hID0gcGFyYW1zLnNjaGVtYTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJJbnZhbGlkIHNjaGVtYS4gU2NoZW1hIG11c3QgYmUgZWl0aGVyIGEgdmFsaWQgWm9kIHNjaGVtYSBvciBKU09OIHNjaGVtYSBvYmplY3QuXCIsIDQwMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMucG9zdFJlcXVlc3QoXG4gICAgICAgIHRoaXMuYXBpVXJsICsgYC92MS9leHRyYWN0YCxcbiAgICAgICAgeyAuLi5qc29uRGF0YSwgc2NoZW1hOiBqc29uU2NoZW1hLCBvcmlnaW46IHR5cGVvZiBwYXJhbXMub3JpZ2luID09PSBcInN0cmluZ1wiICYmIHBhcmFtcy5vcmlnaW4uaW5jbHVkZXMoXCJtY3BcIikgPyBwYXJhbXMub3JpZ2luIDogYGpzLXNka0Ake3RoaXMudmVyc2lvbn1gIH0sXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcInN0YXJ0IGV4dHJhY3Qgam9iXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwLCBlcnJvci5yZXNwb25zZT8uZGF0YT8uZGV0YWlscyk7XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBzdGF0dXMgb2YgYW4gZXh0cmFjdCBqb2IuXG4gICAqIEBwYXJhbSBqb2JJZCAtIFRoZSBJRCBvZiB0aGUgZXh0cmFjdCBqb2IuXG4gICAqIEByZXR1cm5zIFRoZSBzdGF0dXMgb2YgdGhlIGV4dHJhY3Qgam9iLlxuICAgKi9cbiAgYXN5bmMgZ2V0RXh0cmFjdFN0YXR1cyhqb2JJZCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2V4dHJhY3QvJHtqb2JJZH1gLFxuICAgICAgICB0aGlzLnByZXBhcmVIZWFkZXJzKClcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImdldCBleHRyYWN0IHN0YXR1c1wiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBQcmVwYXJlcyB0aGUgaGVhZGVycyBmb3IgYW4gQVBJIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBpZGVtcG90ZW5jeUtleSAtIE9wdGlvbmFsIGtleSB0byBlbnN1cmUgaWRlbXBvdGVuY3kuXG4gICAqIEByZXR1cm5zIFRoZSBwcmVwYXJlZCBoZWFkZXJzLlxuICAgKi9cbiAgcHJlcGFyZUhlYWRlcnMoaWRlbXBvdGVuY3lLZXkpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hcGlLZXl9YCxcbiAgICAgIC4uLmlkZW1wb3RlbmN5S2V5ID8geyBcIngtaWRlbXBvdGVuY3kta2V5XCI6IGlkZW1wb3RlbmN5S2V5IH0gOiB7fVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICAqIFNlbmRzIGEgUE9TVCByZXF1ZXN0IHRvIHRoZSBzcGVjaWZpZWQgVVJMLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gZGF0YSAtIFRoZSBkYXRhIHRvIHNlbmQgaW4gdGhlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSBoZWFkZXJzIC0gVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgZnJvbSB0aGUgUE9TVCByZXF1ZXN0LlxuICAgKi9cbiAgcG9zdFJlcXVlc3QodXJsLCBkYXRhLCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIGF4aW9zMi5wb3N0KHVybCwgZGF0YSwgeyBoZWFkZXJzLCB0aW1lb3V0OiBkYXRhPy50aW1lb3V0ID8gZGF0YS50aW1lb3V0ICsgNWUzIDogdm9pZCAwIH0pO1xuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIEdFVCByZXF1ZXN0IHRvIHRoZSBzcGVjaWZpZWQgVVJMLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gaGVhZGVycyAtIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIEdFVCByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZ2V0UmVxdWVzdCh1cmwsIGhlYWRlcnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zMi5nZXQodXJsLCB7IGhlYWRlcnMgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IgJiYgZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBTZW5kcyBhIERFTEVURSByZXF1ZXN0IHRvIHRoZSBzcGVjaWZpZWQgVVJMLlxuICAgKiBAcGFyYW0gdXJsIC0gVGhlIFVSTCB0byBzZW5kIHRoZSByZXF1ZXN0IHRvLlxuICAgKiBAcGFyYW0gaGVhZGVycyAtIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdC5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGZyb20gdGhlIERFTEVURSByZXF1ZXN0LlxuICAgKi9cbiAgYXN5bmMgZGVsZXRlUmVxdWVzdCh1cmwsIGhlYWRlcnMpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGF3YWl0IGF4aW9zMi5kZWxldGUodXJsLCB7IGhlYWRlcnMgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IgJiYgZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yLnJlc3BvbnNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBNb25pdG9ycyB0aGUgc3RhdHVzIG9mIGEgY3Jhd2wgam9iIHVudGlsIGNvbXBsZXRpb24gb3IgZmFpbHVyZS5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBjcmF3bCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBoZWFkZXJzIC0gVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0gY2hlY2tJbnRlcnZhbCAtIEludGVydmFsIGluIHNlY29uZHMgZm9yIGpvYiBzdGF0dXMgY2hlY2tzLlxuICAgKiBAcGFyYW0gY2hlY2tVcmwgLSBPcHRpb25hbCBVUkwgdG8gY2hlY2sgdGhlIHN0YXR1cyAodXNlZCBmb3IgdjEgQVBJKVxuICAgKiBAcmV0dXJucyBUaGUgZmluYWwgam9iIHN0YXR1cyBvciBkYXRhLlxuICAgKi9cbiAgYXN5bmMgbW9uaXRvckpvYlN0YXR1cyhpZCwgaGVhZGVycywgY2hlY2tJbnRlcnZhbCkge1xuICAgIGxldCBmYWlsZWRUcmllcyA9IDA7XG4gICAgbGV0IG5ldHdvcmtSZXRyaWVzID0gMDtcbiAgICBjb25zdCBtYXhOZXR3b3JrUmV0cmllcyA9IDM7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGxldCBzdGF0dXNSZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvY3Jhd2wvJHtpZH1gLFxuICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgKTtcbiAgICAgICAgaWYgKHN0YXR1c1Jlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgZmFpbGVkVHJpZXMgPSAwO1xuICAgICAgICAgIG5ldHdvcmtSZXRyaWVzID0gMDtcbiAgICAgICAgICBsZXQgc3RhdHVzRGF0YSA9IHN0YXR1c1Jlc3BvbnNlLmRhdGE7XG4gICAgICAgICAgaWYgKHN0YXR1c0RhdGEuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gc3RhdHVzRGF0YSkge1xuICAgICAgICAgICAgICBsZXQgZGF0YSA9IHN0YXR1c0RhdGEuZGF0YTtcbiAgICAgICAgICAgICAgd2hpbGUgKHR5cGVvZiBzdGF0dXNEYXRhID09PSBcIm9iamVjdFwiICYmIFwibmV4dFwiIGluIHN0YXR1c0RhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0dXNSZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChzdGF0dXNEYXRhLm5leHQsIGhlYWRlcnMpO1xuICAgICAgICAgICAgICAgIHN0YXR1c0RhdGEgPSBzdGF0dXNSZXNwb25zZS5kYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBkYXRhLmNvbmNhdChzdGF0dXNEYXRhLmRhdGEpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0YXR1c0RhdGEuZGF0YSA9IGRhdGE7XG4gICAgICAgICAgICAgIHJldHVybiBzdGF0dXNEYXRhO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiQ3Jhd2wgam9iIGNvbXBsZXRlZCBidXQgbm8gZGF0YSB3YXMgcmV0dXJuZWRcIiwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKFtcImFjdGl2ZVwiLCBcInBhdXNlZFwiLCBcInBlbmRpbmdcIiwgXCJxdWV1ZWRcIiwgXCJ3YWl0aW5nXCIsIFwic2NyYXBpbmdcIl0uaW5jbHVkZXMoc3RhdHVzRGF0YS5zdGF0dXMpKSB7XG4gICAgICAgICAgICBjaGVja0ludGVydmFsID0gTWF0aC5tYXgoY2hlY2tJbnRlcnZhbCwgMik7XG4gICAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShcbiAgICAgICAgICAgICAgKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgY2hlY2tJbnRlcnZhbCAqIDFlMylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgICAgICAgYENyYXdsIGpvYiBmYWlsZWQgb3Igd2FzIHN0b3BwZWQuIFN0YXR1czogJHtzdGF0dXNEYXRhLnN0YXR1c31gLFxuICAgICAgICAgICAgICA1MDBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZhaWxlZFRyaWVzKys7XG4gICAgICAgICAgaWYgKGZhaWxlZFRyaWVzID49IDMpIHtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlRXJyb3Ioc3RhdHVzUmVzcG9uc2UsIFwiY2hlY2sgY3Jhd2wgc3RhdHVzXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNSZXRyeWFibGVFcnJvcihlcnJvcikgJiYgbmV0d29ya1JldHJpZXMgPCBtYXhOZXR3b3JrUmV0cmllcykge1xuICAgICAgICAgIG5ldHdvcmtSZXRyaWVzKys7XG4gICAgICAgICAgY29uc3QgYmFja29mZkRlbGF5ID0gTWF0aC5taW4oMWUzICogTWF0aC5wb3coMiwgbmV0d29ya1JldHJpZXMgLSAxKSwgMWU0KTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBiYWNrb2ZmRGVsYXkpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIGlmIGFuIGVycm9yIGlzIHJldHJ5YWJsZSAodHJhbnNpZW50IG5ldHdvcmsgZXJyb3IpXG4gICAqIEBwYXJhbSBlcnJvciAtIFRoZSBlcnJvciB0byBjaGVja1xuICAgKiBAcmV0dXJucyBUcnVlIGlmIHRoZSBlcnJvciBzaG91bGQgYmUgcmV0cmllZFxuICAgKi9cbiAgaXNSZXRyeWFibGVFcnJvcihlcnJvcikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEF4aW9zRXJyb3IpIHtcbiAgICAgIGlmICghZXJyb3IucmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGVycm9yLmNvZGU7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlPy50b0xvd2VyQ2FzZSgpIHx8IFwiXCI7XG4gICAgICAgIHJldHVybiBjb2RlID09PSBcIkVDT05OUkVTRVRcIiB8fCBjb2RlID09PSBcIkVUSU1FRE9VVFwiIHx8IGNvZGUgPT09IFwiRU5PVEZPVU5EXCIgfHwgY29kZSA9PT0gXCJFQ09OTlJFRlVTRURcIiB8fCBtZXNzYWdlLmluY2x1ZGVzKFwic29ja2V0IGhhbmcgdXBcIikgfHwgbWVzc2FnZS5pbmNsdWRlcyhcIm5ldHdvcmsgZXJyb3JcIikgfHwgbWVzc2FnZS5pbmNsdWRlcyhcInRpbWVvdXRcIik7XG4gICAgICB9XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNDA4IHx8IGVycm9yLnJlc3BvbnNlPy5zdGF0dXMgPT09IDUwNCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVycm9yICYmIHR5cGVvZiBlcnJvciA9PT0gXCJvYmplY3RcIikge1xuICAgICAgY29uc3QgY29kZSA9IGVycm9yLmNvZGU7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZT8udG9Mb3dlckNhc2UoKSB8fCBcIlwiO1xuICAgICAgaWYgKGNvZGUgPT09IFwiRUNPTk5SRVNFVFwiIHx8IGNvZGUgPT09IFwiRVRJTUVET1VUXCIgfHwgY29kZSA9PT0gXCJFTk9URk9VTkRcIiB8fCBjb2RlID09PSBcIkVDT05OUkVGVVNFRFwiIHx8IG1lc3NhZ2UuaW5jbHVkZXMoXCJzb2NrZXQgaGFuZyB1cFwiKSB8fCBtZXNzYWdlLmluY2x1ZGVzKFwibmV0d29yayBlcnJvclwiKSB8fCBtZXNzYWdlLmluY2x1ZGVzKFwidGltZW91dFwiKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uc3RhdHVzID09PSA0MDggfHwgZXJyb3IucmVzcG9uc2U/LnN0YXR1cyA9PT0gNTA0KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICAqIEhhbmRsZXMgZXJyb3JzIGZyb20gQVBJIHJlc3BvbnNlcy5cbiAgICogQHBhcmFtIHtBeGlvc1Jlc3BvbnNlfSByZXNwb25zZSAtIFRoZSByZXNwb25zZSBmcm9tIHRoZSBBUEkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhY3Rpb24gLSBUaGUgYWN0aW9uIGJlaW5nIHBlcmZvcm1lZCB3aGVuIHRoZSBlcnJvciBvY2N1cnJlZC5cbiAgICovXG4gIGhhbmRsZUVycm9yKHJlc3BvbnNlLCBhY3Rpb24pIHtcbiAgICBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXG4gICAgICAgIGBObyByZXNwb25zZSByZWNlaXZlZCB3aGlsZSB0cnlpbmcgdG8gJHthY3Rpb259LiBUaGlzIG1heSBiZSBhIG5ldHdvcmsgZXJyb3Igb3IgdGhlIHNlcnZlciBpcyB1bnJlYWNoYWJsZS5gLFxuICAgICAgICAwXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoWzQwMCwgNDAyLCA0MDMsIDQwOCwgNDA5LCA1MDBdLmluY2x1ZGVzKHJlc3BvbnNlLnN0YXR1cykpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9IHJlc3BvbnNlLmRhdGEuZXJyb3IgfHwgXCJVbmtub3duIGVycm9yIG9jY3VycmVkXCI7XG4gICAgICBjb25zdCBkZXRhaWxzID0gcmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkocmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIjtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgYEZhaWxlZCB0byAke2FjdGlvbn0uIFN0YXR1cyBjb2RlOiAke3Jlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yTWVzc2FnZX0ke2RldGFpbHN9YCxcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZT8uZGF0YT8uZGV0YWlsc1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZCBlcnJvciBvY2N1cnJlZCB3aGlsZSB0cnlpbmcgdG8gJHthY3Rpb259LiBTdGF0dXMgY29kZTogJHtyZXNwb25zZS5zdGF0dXN9YCxcbiAgICAgICAgcmVzcG9uc2Uuc3RhdHVzXG4gICAgICApO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogSW5pdGlhdGVzIGEgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24gb24gYSBnaXZlbiBxdWVyeSBhbmQgcG9sbHMgdW50aWwgY29tcGxldGlvbi5cbiAgICogQHBhcmFtIHF1ZXJ5IC0gVGhlIHF1ZXJ5IHRvIHJlc2VhcmNoLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIGRlZXAgcmVzZWFyY2ggb3BlcmF0aW9uLlxuICAgKiBAcGFyYW0gb25BY3Rpdml0eSAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlY2VpdmUgYWN0aXZpdHkgdXBkYXRlcyBpbiByZWFsLXRpbWUuXG4gICAqIEBwYXJhbSBvblNvdXJjZSAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlY2VpdmUgc291cmNlIHVwZGF0ZXMgaW4gcmVhbC10aW1lLlxuICAgKiBAcmV0dXJucyBUaGUgZmluYWwgcmVzZWFyY2ggcmVzdWx0cy5cbiAgICovXG4gIGFzeW5jIGRlZXBSZXNlYXJjaChxdWVyeSwgcGFyYW1zLCBvbkFjdGl2aXR5LCBvblNvdXJjZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuYXN5bmNEZWVwUmVzZWFyY2gocXVlcnksIHBhcmFtcyk7XG4gICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgfHwgXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJlcnJvclwiIGluIHJlc3BvbnNlID8gcmVzcG9uc2UuZXJyb3IgOiBcIlVua25vd24gZXJyb3JcIiB9O1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwb25zZS5pZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEZhaWxlZCB0byBzdGFydCByZXNlYXJjaC4gTm8gam9iIElEIHJldHVybmVkLmAsIDUwMCk7XG4gICAgICB9XG4gICAgICBjb25zdCBqb2JJZCA9IHJlc3BvbnNlLmlkO1xuICAgICAgbGV0IHJlc2VhcmNoU3RhdHVzO1xuICAgICAgbGV0IGxhc3RBY3Rpdml0eUNvdW50ID0gMDtcbiAgICAgIGxldCBsYXN0U291cmNlQ291bnQgPSAwO1xuICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgcmVzZWFyY2hTdGF0dXMgPSBhd2FpdCB0aGlzLmNoZWNrRGVlcFJlc2VhcmNoU3RhdHVzKGpvYklkKTtcbiAgICAgICAgaWYgKFwiZXJyb3JcIiBpbiByZXNlYXJjaFN0YXR1cyAmJiAhcmVzZWFyY2hTdGF0dXMuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXNlYXJjaFN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBpZiAob25BY3Rpdml0eSAmJiByZXNlYXJjaFN0YXR1cy5hY3Rpdml0aWVzKSB7XG4gICAgICAgICAgY29uc3QgbmV3QWN0aXZpdGllcyA9IHJlc2VhcmNoU3RhdHVzLmFjdGl2aXRpZXMuc2xpY2UobGFzdEFjdGl2aXR5Q291bnQpO1xuICAgICAgICAgIGZvciAoY29uc3QgYWN0aXZpdHkgb2YgbmV3QWN0aXZpdGllcykge1xuICAgICAgICAgICAgb25BY3Rpdml0eShhY3Rpdml0eSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RBY3Rpdml0eUNvdW50ID0gcmVzZWFyY2hTdGF0dXMuYWN0aXZpdGllcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uU291cmNlICYmIHJlc2VhcmNoU3RhdHVzLnNvdXJjZXMpIHtcbiAgICAgICAgICBjb25zdCBuZXdTb3VyY2VzID0gcmVzZWFyY2hTdGF0dXMuc291cmNlcy5zbGljZShsYXN0U291cmNlQ291bnQpO1xuICAgICAgICAgIGZvciAoY29uc3Qgc291cmNlIG9mIG5ld1NvdXJjZXMpIHtcbiAgICAgICAgICAgIG9uU291cmNlKHNvdXJjZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGxhc3RTb3VyY2VDb3VudCA9IHJlc2VhcmNoU3RhdHVzLnNvdXJjZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNlYXJjaFN0YXR1cy5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzZWFyY2hTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2VhcmNoU3RhdHVzLnN0YXR1cyA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgICAgIGBSZXNlYXJjaCBqb2IgJHtyZXNlYXJjaFN0YXR1cy5zdGF0dXN9LiBFcnJvcjogJHtyZXNlYXJjaFN0YXR1cy5lcnJvcn1gLFxuICAgICAgICAgICAgNTAwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZWFyY2hTdGF0dXMuc3RhdHVzICE9PSBcInByb2Nlc3NpbmdcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDJlMykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIlJlc2VhcmNoIGpvYiB0ZXJtaW5hdGVkIHVuZXhwZWN0ZWRseVwiIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIGRlZXAgcmVzZWFyY2ggb3BlcmF0aW9uIG9uIGEgZ2l2ZW4gcXVlcnkgd2l0aG91dCBwb2xsaW5nLlxuICAgKiBAcGFyYW0gcGFyYW1zIC0gUGFyYW1ldGVycyBmb3IgdGhlIGRlZXAgcmVzZWFyY2ggb3BlcmF0aW9uLlxuICAgKiBAcmV0dXJucyBUaGUgcmVzcG9uc2UgY29udGFpbmluZyB0aGUgcmVzZWFyY2ggam9iIElELlxuICAgKi9cbiAgYXN5bmMgYXN5bmNEZWVwUmVzZWFyY2gocXVlcnksIHBhcmFtcykge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgbGV0IGpzb25EYXRhID0geyBxdWVyeSwgLi4ucGFyYW1zLCBvcmlnaW46IHR5cGVvZiBwYXJhbXMub3JpZ2luID09PSBcInN0cmluZ1wiICYmIHBhcmFtcy5vcmlnaW4uaW5jbHVkZXMoXCJtY3BcIikgPyBwYXJhbXMub3JpZ2luIDogYGpzLXNka0Ake3RoaXMudmVyc2lvbn1gIH07XG4gICAgaWYgKGpzb25EYXRhPy5qc29uT3B0aW9ucz8uc2NoZW1hKSB7XG4gICAgICBsZXQgc2NoZW1hID0ganNvbkRhdGEuanNvbk9wdGlvbnMuc2NoZW1hO1xuICAgICAgdHJ5IHtcbiAgICAgICAgc2NoZW1hID0gem9kVG9Kc29uU2NoZW1hMyhzY2hlbWEpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIH1cbiAgICAgIGpzb25EYXRhID0ge1xuICAgICAgICAuLi5qc29uRGF0YSxcbiAgICAgICAganNvbk9wdGlvbnM6IHtcbiAgICAgICAgICAuLi5qc29uRGF0YS5qc29uT3B0aW9ucyxcbiAgICAgICAgICBzY2hlbWFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2RlZXAtcmVzZWFyY2hgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgZGVlcCByZXNlYXJjaFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgc3RhdHVzIG9mIGEgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXR1cyBhbmQgcmVzdWx0cyBvZiB0aGUgcmVzZWFyY2ggb3BlcmF0aW9uLlxuICAgKi9cbiAgYXN5bmMgY2hlY2tEZWVwUmVzZWFyY2hTdGF0dXMoaWQpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2RlZXAtcmVzZWFyY2gvJHtpZH1gLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJEZWVwIHJlc2VhcmNoIGpvYiBub3QgZm91bmRcIiwgNDA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiY2hlY2sgZGVlcCByZXNlYXJjaCBzdGF0dXNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgZGVlcFJlc2VhcmNoKCkgaW5zdGVhZFxuICAgKiBJbml0aWF0ZXMgYSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbiBvbiBhIGdpdmVuIHRvcGljIGFuZCBwb2xscyB1bnRpbCBjb21wbGV0aW9uLlxuICAgKiBAcGFyYW0gdG9waWMgLSBUaGUgdG9waWMgdG8gcmVzZWFyY2guXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBvbkFjdGl2aXR5IC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVjZWl2ZSBhY3Rpdml0eSB1cGRhdGVzIGluIHJlYWwtdGltZS5cbiAgICogQHJldHVybnMgVGhlIGZpbmFsIHJlc2VhcmNoIHJlc3VsdHMuXG4gICAqL1xuICBhc3luYyBfX2RlZXBSZXNlYXJjaCh0b3BpYywgcGFyYW1zLCBvbkFjdGl2aXR5KSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5fX2FzeW5jRGVlcFJlc2VhcmNoKHRvcGljLCBwYXJhbXMpO1xuICAgICAgaWYgKCFyZXNwb25zZS5zdWNjZXNzIHx8IFwiZXJyb3JcIiBpbiByZXNwb25zZSkge1xuICAgICAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiZXJyb3JcIiBpbiByZXNwb25zZSA/IHJlc3BvbnNlLmVycm9yIDogXCJVbmtub3duIGVycm9yXCIgfTtcbiAgICAgIH1cbiAgICAgIGlmICghcmVzcG9uc2UuaWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBGYWlsZWQgdG8gc3RhcnQgcmVzZWFyY2guIE5vIGpvYiBJRCByZXR1cm5lZC5gLCA1MDApO1xuICAgICAgfVxuICAgICAgY29uc3Qgam9iSWQgPSByZXNwb25zZS5pZDtcbiAgICAgIGxldCByZXNlYXJjaFN0YXR1cztcbiAgICAgIGxldCBsYXN0QWN0aXZpdHlDb3VudCA9IDA7XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICByZXNlYXJjaFN0YXR1cyA9IGF3YWl0IHRoaXMuX19jaGVja0RlZXBSZXNlYXJjaFN0YXR1cyhqb2JJZCk7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gcmVzZWFyY2hTdGF0dXMgJiYgIXJlc2VhcmNoU3RhdHVzLnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gcmVzZWFyY2hTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9uQWN0aXZpdHkgJiYgcmVzZWFyY2hTdGF0dXMuYWN0aXZpdGllcykge1xuICAgICAgICAgIGNvbnN0IG5ld0FjdGl2aXRpZXMgPSByZXNlYXJjaFN0YXR1cy5hY3Rpdml0aWVzLnNsaWNlKGxhc3RBY3Rpdml0eUNvdW50KTtcbiAgICAgICAgICBmb3IgKGNvbnN0IGFjdGl2aXR5IG9mIG5ld0FjdGl2aXRpZXMpIHtcbiAgICAgICAgICAgIG9uQWN0aXZpdHkoYWN0aXZpdHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsYXN0QWN0aXZpdHlDb3VudCA9IHJlc2VhcmNoU3RhdHVzLmFjdGl2aXRpZXMubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXNlYXJjaFN0YXR1cy5zdGF0dXMgPT09IFwiY29tcGxldGVkXCIpIHtcbiAgICAgICAgICByZXR1cm4gcmVzZWFyY2hTdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc2VhcmNoU3RhdHVzLnN0YXR1cyA9PT0gXCJmYWlsZWRcIikge1xuICAgICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihcbiAgICAgICAgICAgIGBSZXNlYXJjaCBqb2IgJHtyZXNlYXJjaFN0YXR1cy5zdGF0dXN9LiBFcnJvcjogJHtyZXNlYXJjaFN0YXR1cy5lcnJvcn1gLFxuICAgICAgICAgICAgNTAwXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzZWFyY2hTdGF0dXMuc3RhdHVzICE9PSBcInByb2Nlc3NpbmdcIikge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDJlMykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIlJlc2VhcmNoIGpvYiB0ZXJtaW5hdGVkIHVuZXhwZWN0ZWRseVwiIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBhc3luY0RlZXBSZXNlYXJjaCgpIGluc3RlYWRcbiAgICogSW5pdGlhdGVzIGEgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24gb24gYSBnaXZlbiB0b3BpYyB3aXRob3V0IHBvbGxpbmcuXG4gICAqIEBwYXJhbSBwYXJhbXMgLSBQYXJhbWV0ZXJzIGZvciB0aGUgZGVlcCByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSByZXNlYXJjaCBqb2IgSUQuXG4gICAqL1xuICBhc3luYyBfX2FzeW5jRGVlcFJlc2VhcmNoKHRvcGljLCBwYXJhbXMpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBsZXQganNvbkRhdGEgPSB7IHRvcGljLCAuLi5wYXJhbXMsIG9yaWdpbjogdHlwZW9mIHBhcmFtcy5vcmlnaW4gPT09IFwic3RyaW5nXCIgJiYgcGFyYW1zLm9yaWdpbi5pbmNsdWRlcyhcIm1jcFwiKSA/IHBhcmFtcy5vcmlnaW4gOiBganMtc2RrQCR7dGhpcy52ZXJzaW9ufWAgfTtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2RlZXAtcmVzZWFyY2hgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgZGVlcCByZXNlYXJjaFwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBjaGVja0RlZXBSZXNlYXJjaFN0YXR1cygpIGluc3RlYWRcbiAgICogQ2hlY2tzIHRoZSBzdGF0dXMgb2YgYSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHBhcmFtIGlkIC0gVGhlIElEIG9mIHRoZSBkZWVwIHJlc2VhcmNoIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIGN1cnJlbnQgc3RhdHVzIGFuZCByZXN1bHRzIG9mIHRoZSByZXNlYXJjaCBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBfX2NoZWNrRGVlcFJlc2VhcmNoU3RhdHVzKGlkKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3QoXG4gICAgICAgIGAke3RoaXMuYXBpVXJsfS92MS9kZWVwLXJlc2VhcmNoLyR7aWR9YCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFwiRGVlcCByZXNlYXJjaCBqb2Igbm90IGZvdW5kXCIsIDQwNCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImNoZWNrIGRlZXAgcmVzZWFyY2ggc3RhdHVzXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3J9ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIn1gLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGVzIExMTXMudHh0IGZvciBhIGdpdmVuIFVSTCBhbmQgcG9sbHMgdW50aWwgY29tcGxldGlvbi5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gZ2VuZXJhdGUgTExNcy50eHQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBMTE1zLnR4dCBnZW5lcmF0aW9uIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIGZpbmFsIGdlbmVyYXRpb24gcmVzdWx0cy5cbiAgICovXG4gIGFzeW5jIGdlbmVyYXRlTExNc1RleHQodXJsLCBwYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmFzeW5jR2VuZXJhdGVMTE1zVGV4dCh1cmwsIHBhcmFtcyk7XG4gICAgICBpZiAoIXJlc3BvbnNlLnN1Y2Nlc3MgfHwgXCJlcnJvclwiIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJlcnJvclwiIGluIHJlc3BvbnNlID8gcmVzcG9uc2UuZXJyb3IgOiBcIlVua25vd24gZXJyb3JcIiB9O1xuICAgICAgfVxuICAgICAgaWYgKCFyZXNwb25zZS5pZCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYEZhaWxlZCB0byBzdGFydCBMTE1zLnR4dCBnZW5lcmF0aW9uLiBObyBqb2IgSUQgcmV0dXJuZWQuYCwgNTAwKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGpvYklkID0gcmVzcG9uc2UuaWQ7XG4gICAgICBsZXQgZ2VuZXJhdGlvblN0YXR1cztcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGdlbmVyYXRpb25TdGF0dXMgPSBhd2FpdCB0aGlzLmNoZWNrR2VuZXJhdGVMTE1zVGV4dFN0YXR1cyhqb2JJZCk7XG4gICAgICAgIGlmIChcImVycm9yXCIgaW4gZ2VuZXJhdGlvblN0YXR1cyAmJiAhZ2VuZXJhdGlvblN0YXR1cy5zdWNjZXNzKSB7XG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRpb25TdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVyYXRpb25TdGF0dXMuc3RhdHVzID09PSBcImNvbXBsZXRlZFwiKSB7XG4gICAgICAgICAgcmV0dXJuIGdlbmVyYXRpb25TdGF0dXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGdlbmVyYXRpb25TdGF0dXMuc3RhdHVzID09PSBcImZhaWxlZFwiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKFxuICAgICAgICAgICAgYExMTXMudHh0IGdlbmVyYXRpb24gam9iICR7Z2VuZXJhdGlvblN0YXR1cy5zdGF0dXN9LiBFcnJvcjogJHtnZW5lcmF0aW9uU3RhdHVzLmVycm9yfWAsXG4gICAgICAgICAgICA1MDBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5lcmF0aW9uU3RhdHVzLnN0YXR1cyAhPT0gXCJwcm9jZXNzaW5nXCIpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCAyZTMpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJMTE1zLnR4dCBnZW5lcmF0aW9uIGpvYiB0ZXJtaW5hdGVkIHVuZXhwZWN0ZWRseVwiIH07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDAsIGVycm9yLnJlc3BvbnNlPy5kYXRhPy5kZXRhaWxzKTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEluaXRpYXRlcyBhIExMTXMudHh0IGdlbmVyYXRpb24gb3BlcmF0aW9uIHdpdGhvdXQgcG9sbGluZy5cbiAgICogQHBhcmFtIHVybCAtIFRoZSBVUkwgdG8gZ2VuZXJhdGUgTExNcy50eHQgZnJvbS5cbiAgICogQHBhcmFtIHBhcmFtcyAtIFBhcmFtZXRlcnMgZm9yIHRoZSBMTE1zLnR4dCBnZW5lcmF0aW9uIG9wZXJhdGlvbi5cbiAgICogQHJldHVybnMgVGhlIHJlc3BvbnNlIGNvbnRhaW5pbmcgdGhlIGdlbmVyYXRpb24gam9iIElELlxuICAgKi9cbiAgYXN5bmMgYXN5bmNHZW5lcmF0ZUxMTXNUZXh0KHVybCwgcGFyYW1zKSB7XG4gICAgY29uc3QgaGVhZGVycyA9IHRoaXMucHJlcGFyZUhlYWRlcnMoKTtcbiAgICBsZXQganNvbkRhdGEgPSB7IHVybCwgLi4ucGFyYW1zLCBvcmlnaW46IHR5cGVvZiBwYXJhbXMub3JpZ2luID09PSBcInN0cmluZ1wiICYmIHBhcmFtcy5vcmlnaW4uaW5jbHVkZXMoXCJtY3BcIikgPyBwYXJhbXMub3JpZ2luIDogYGpzLXNka0Ake3RoaXMudmVyc2lvbn1gIH07XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5wb3N0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2xsbXN0eHRgLFxuICAgICAgICBqc29uRGF0YSxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwic3RhcnQgTExNcy50eHQgZ2VuZXJhdGlvblwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgc3RhdHVzIG9mIGEgTExNcy50eHQgZ2VuZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqIEBwYXJhbSBpZCAtIFRoZSBJRCBvZiB0aGUgTExNcy50eHQgZ2VuZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHN0YXR1cyBhbmQgcmVzdWx0cyBvZiB0aGUgZ2VuZXJhdGlvbiBvcGVyYXRpb24uXG4gICAqL1xuICBhc3luYyBjaGVja0dlbmVyYXRlTExNc1RleHRTdGF0dXMoaWQpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL2xsbXN0eHQvJHtpZH1gLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDQwNCkge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoXCJMTE1zLnR4dCBnZW5lcmF0aW9uIGpvYiBub3QgZm91bmRcIiwgNDA0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiY2hlY2sgTExNcy50eHQgZ2VuZXJhdGlvbiBzdGF0dXNcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIG1ldHJpY3MgYWJvdXQgdGhlIHRlYW0ncyBzY3JhcGUgcXVldWUuXG4gICAqIEByZXR1cm5zIFRoZSBjdXJyZW50IHF1ZXVlIHN0YXR1cy5cbiAgICovXG4gIGFzeW5jIGdldFF1ZXVlU3RhdHVzKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KFxuICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvdGVhbS9xdWV1ZS1zdGF0dXNgLFxuICAgICAgICBoZWFkZXJzXG4gICAgICApO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJnZXQgcXVldWUgc3RhdHVzXCIpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoZXJyb3IucmVzcG9uc2U/LmRhdGE/LmVycm9yKSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihgUmVxdWVzdCBmYWlsZWQgd2l0aCBzdGF0dXMgY29kZSAke2Vycm9yLnJlc3BvbnNlLnN0YXR1c30uIEVycm9yOiAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZXJyb3J9ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzID8gYCAtICR7SlNPTi5zdHJpbmdpZnkoZXJyb3IucmVzcG9uc2UuZGF0YS5kZXRhaWxzKX1gIDogXCJcIn1gLCBlcnJvci5yZXNwb25zZS5zdGF0dXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGVycm9yLm1lc3NhZ2UsIDUwMCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogXCJJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IuXCIgfTtcbiAgfVxuICAvKipcbiAgICogR2V0cyBjdXJyZW50IGNyZWRpdCB1c2FnZSBhbmQgYmlsbGluZyBwZXJpb2QgZm9yIHRoZSB0ZWFtICh2MSkuXG4gICAqL1xuICBhc3luYyBnZXRDcmVkaXRVc2FnZSgpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdChcbiAgICAgICAgYCR7dGhpcy5hcGlVcmx9L3YxL3RlYW0vY3JlZGl0LXVzYWdlYCxcbiAgICAgICAgaGVhZGVyc1xuICAgICAgKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiZ2V0IGNyZWRpdCB1c2FnZVwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgY3VycmVudCB0b2tlbiB1c2FnZSBhbmQgYmlsbGluZyBwZXJpb2QgZm9yIHRoZSB0ZWFtICh2MSkuXG4gICAqL1xuICBhc3luYyBnZXRUb2tlblVzYWdlKCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgdGhpcy5nZXRSZXF1ZXN0KFxuICAgICAgICBgJHt0aGlzLmFwaVVybH0vdjEvdGVhbS90b2tlbi11c2FnZWAsXG4gICAgICAgIGhlYWRlcnNcbiAgICAgICk7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRhdGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmhhbmRsZUVycm9yKHJlc3BvbnNlLCBcImdldCB0b2tlbiB1c2FnZVwiKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yLnJlc3BvbnNlPy5kYXRhPy5lcnJvcikge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoYFJlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJHtlcnJvci5yZXNwb25zZS5zdGF0dXN9LiBFcnJvcjogJHtlcnJvci5yZXNwb25zZS5kYXRhLmVycm9yfSAke2Vycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyA/IGAgLSAke0pTT04uc3RyaW5naWZ5KGVycm9yLnJlc3BvbnNlLmRhdGEuZGV0YWlscyl9YCA6IFwiXCJ9YCwgZXJyb3IucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBGaXJlY3Jhd2xFcnJvcihlcnJvci5tZXNzYWdlLCA1MDApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IFwiSW50ZXJuYWwgc2VydmVyIGVycm9yLlwiIH07XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgaGlzdG9yaWNhbCBjcmVkaXQgdXNhZ2UuIFBhc3MgYnlBcGlLZXk9dHJ1ZSB0byBicmVhayBkb3duIGJ5IEFQSSBrZXkuXG4gICAqL1xuICBhc3luYyBnZXRDcmVkaXRVc2FnZUhpc3RvcmljYWwoYnlBcGlLZXkpIHtcbiAgICBjb25zdCBoZWFkZXJzID0gdGhpcy5wcmVwYXJlSGVhZGVycygpO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmFwaVVybH0vdjEvdGVhbS9jcmVkaXQtdXNhZ2UvaGlzdG9yaWNhbCR7YnlBcGlLZXkgPyBcIj9ieUFwaUtleT10cnVlXCIgOiBcIlwifWA7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuZ2V0UmVxdWVzdCh1cmwsIGhlYWRlcnMpO1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZS5kYXRhO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5oYW5kbGVFcnJvcihyZXNwb25zZSwgXCJnZXQgY3JlZGl0IHVzYWdlIGhpc3RvcmljYWxcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG4gIC8qKlxuICAgKiBHZXRzIGhpc3RvcmljYWwgdG9rZW4gdXNhZ2UuIFBhc3MgYnlBcGlLZXk9dHJ1ZSB0byBicmVhayBkb3duIGJ5IEFQSSBrZXkuXG4gICAqL1xuICBhc3luYyBnZXRUb2tlblVzYWdlSGlzdG9yaWNhbChieUFwaUtleSkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB0aGlzLnByZXBhcmVIZWFkZXJzKCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHVybCA9IGAke3RoaXMuYXBpVXJsfS92MS90ZWFtL3Rva2VuLXVzYWdlL2hpc3RvcmljYWwke2J5QXBpS2V5ID8gXCI/YnlBcGlLZXk9dHJ1ZVwiIDogXCJcIn1gO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmdldFJlcXVlc3QodXJsLCBoZWFkZXJzKTtcbiAgICAgIGlmIChyZXNwb25zZS5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuaGFuZGxlRXJyb3IocmVzcG9uc2UsIFwiZ2V0IHRva2VuIHVzYWdlIGhpc3RvcmljYWxcIik7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvci5yZXNwb25zZT8uZGF0YT8uZXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEZpcmVjcmF3bEVycm9yKGBSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICR7ZXJyb3IucmVzcG9uc2Uuc3RhdHVzfS4gRXJyb3I6ICR7ZXJyb3IucmVzcG9uc2UuZGF0YS5lcnJvcn0gJHtlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMgPyBgIC0gJHtKU09OLnN0cmluZ2lmeShlcnJvci5yZXNwb25zZS5kYXRhLmRldGFpbHMpfWAgOiBcIlwifWAsIGVycm9yLnJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRmlyZWNyYXdsRXJyb3IoZXJyb3IubWVzc2FnZSwgNTAwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiBcIkludGVybmFsIHNlcnZlciBlcnJvci5cIiB9O1xuICB9XG59O1xudmFyIENyYXdsV2F0Y2hlciA9IGNsYXNzIGV4dGVuZHMgZSB7XG4gIHdzO1xuICBkYXRhO1xuICBzdGF0dXM7XG4gIGlkO1xuICBjb25zdHJ1Y3RvcihpZCwgYXBwKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmlkID0gaWQ7XG4gICAgY29uc3Qgd3NVcmwgPSBhcHAuYXBpVXJsLnJlcGxhY2UoL15odHRwLywgXCJ3c1wiKTtcbiAgICB0aGlzLndzID0gbmV3IFdlYlNvY2tldChgJHt3c1VybH0vdjEvY3Jhd2wvJHtpZH1gLCBhcHAuYXBpS2V5KTtcbiAgICB0aGlzLnN0YXR1cyA9IFwic2NyYXBpbmdcIjtcbiAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IChtc2cpID0+IHtcbiAgICAgIGlmIChtc2cudHlwZSA9PT0gXCJkb25lXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBcImNvbXBsZXRlZFwiO1xuICAgICAgICB0aGlzLmRpc3BhdGNoVHlwZWRFdmVudChcImRvbmVcIiwgbmV3IEN1c3RvbUV2ZW50KFwiZG9uZVwiLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBzdGF0dXM6IHRoaXMuc3RhdHVzLFxuICAgICAgICAgICAgZGF0YTogdGhpcy5kYXRhLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgIH0gZWxzZSBpZiAobXNnLnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICB0aGlzLnN0YXR1cyA9IFwiZmFpbGVkXCI7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hUeXBlZEV2ZW50KFwiZXJyb3JcIiwgbmV3IEN1c3RvbUV2ZW50KFwiZXJyb3JcIiwge1xuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGVycm9yOiBtc2cuZXJyb3IsXG4gICAgICAgICAgICBpZDogdGhpcy5pZFxuICAgICAgICAgIH1cbiAgICAgICAgfSkpO1xuICAgICAgfSBlbHNlIGlmIChtc2cudHlwZSA9PT0gXCJjYXRjaHVwXCIpIHtcbiAgICAgICAgdGhpcy5zdGF0dXMgPSBtc2cuZGF0YS5zdGF0dXM7XG4gICAgICAgIHRoaXMuZGF0YS5wdXNoKC4uLm1zZy5kYXRhLmRhdGEgPz8gW10pO1xuICAgICAgICBmb3IgKGNvbnN0IGRvYyBvZiB0aGlzLmRhdGEpIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoVHlwZWRFdmVudChcImRvY3VtZW50XCIsIG5ldyBDdXN0b21FdmVudChcImRvY3VtZW50XCIsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAuLi5kb2MsXG4gICAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG1zZy50eXBlID09PSBcImRvY3VtZW50XCIpIHtcbiAgICAgICAgdGhpcy5kaXNwYXRjaFR5cGVkRXZlbnQoXCJkb2N1bWVudFwiLCBuZXcgQ3VzdG9tRXZlbnQoXCJkb2N1bWVudFwiLCB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAuLi5tc2cuZGF0YSxcbiAgICAgICAgICAgIGlkOiB0aGlzLmlkXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB0aGlzLndzLm9ubWVzc2FnZSA9ICgoZXYpID0+IHtcbiAgICAgIGlmICh0eXBlb2YgZXYuZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG1zZyA9IEpTT04ucGFyc2UoZXYuZGF0YSk7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyKG1zZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igb24gbWVzc2FnZVwiLCBlcnJvcik7XG4gICAgICB9XG4gICAgfSkuYmluZCh0aGlzKTtcbiAgICB0aGlzLndzLm9uY2xvc2UgPSAoKGV2KSA9PiB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBtc2cgPSBKU09OLnBhcnNlKGV2LnJlYXNvbik7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyKG1zZyk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKFwiRXJyb3Igb24gY2xvc2VcIiwgZXJyb3IpO1xuICAgICAgfVxuICAgIH0pLmJpbmQodGhpcyk7XG4gICAgdGhpcy53cy5vbmVycm9yID0gKChfKSA9PiB7XG4gICAgICB0aGlzLnN0YXR1cyA9IFwiZmFpbGVkXCI7XG4gICAgICB0aGlzLmRpc3BhdGNoVHlwZWRFdmVudChcImVycm9yXCIsIG5ldyBDdXN0b21FdmVudChcImVycm9yXCIsIHtcbiAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgc3RhdHVzOiB0aGlzLnN0YXR1cyxcbiAgICAgICAgICBkYXRhOiB0aGlzLmRhdGEsXG4gICAgICAgICAgZXJyb3I6IFwiV2ViU29ja2V0IGVycm9yXCIsXG4gICAgICAgICAgaWQ6IHRoaXMuaWRcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH0pLmJpbmQodGhpcyk7XG4gIH1cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy53cy5jbG9zZSgpO1xuICB9XG59O1xuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBGaXJlY3Jhd2wgPSBjbGFzcyBleHRlbmRzIEZpcmVjcmF3bENsaWVudCB7XG4gIC8qKiBGZWF0dXJl4oCRZnJvemVuIHYxIGNsaWVudCAobGF6eSkuICovXG4gIF92MTtcbiAgX3YxT3B0cztcbiAgLyoqIEBwYXJhbSBvcHRzIEFQSSBjcmVkZW50aWFscyBhbmQgYmFzZSBVUkwuICovXG4gIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgIHN1cGVyKG9wdHMpO1xuICAgIHRoaXMuX3YxT3B0cyA9IHtcbiAgICAgIGFwaUtleTogb3B0cy5hcGlLZXksXG4gICAgICBhcGlVcmw6IG9wdHMuYXBpVXJsXG4gICAgfTtcbiAgfVxuICAvKiogQWNjZXNzIHRoZSBsZWdhY3kgdjEgY2xpZW50IChpbnN0YW50aWF0ZWQgb24gZmlyc3QgYWNjZXNzKS4gKi9cbiAgZ2V0IHYxKCkge1xuICAgIGlmICghdGhpcy5fdjEpIHRoaXMuX3YxID0gbmV3IEZpcmVjcmF3bEFwcCh0aGlzLl92MU9wdHMpO1xuICAgIHJldHVybiB0aGlzLl92MTtcbiAgfVxufTtcbnZhciBpbmRleF9kZWZhdWx0ID0gRmlyZWNyYXdsO1xuZXhwb3J0IHtcbiAgRmlyZWNyYXdsLFxuICBGaXJlY3Jhd2xBcHAgYXMgRmlyZWNyYXdsQXBwVjEsXG4gIEZpcmVjcmF3bENsaWVudCxcbiAgU2RrRXJyb3IsXG4gIGluZGV4X2RlZmF1bHQgYXMgZGVmYXVsdFxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mendable/firecrawl-js/dist/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@mendable/firecrawl-js/dist/package-SYKCM5JT.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@mendable/firecrawl-js/dist/package-SYKCM5JT.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _chunk_J3BEBX3Y_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunk-J3BEBX3Y.js */ \"(ssr)/./node_modules/@mendable/firecrawl-js/dist/chunk-J3BEBX3Y.js\");\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,_chunk_J3BEBX3Y_js__WEBPACK_IMPORTED_MODULE_0__.require_package)());\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1lbmRhYmxlL2ZpcmVjcmF3bC1qcy9kaXN0L3BhY2thZ2UtU1lLQ001SlQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFFNkI7QUFDN0IsaUVBQWUsbUVBQWUsRUFBRSxFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvbm1hbWxvb2svRGVza3RvcC9TaWRlLVByb2plY3RzL0FnZW50LVdvcmtmbG93LUJ1aWxkZXItUHJvamVjdC9ub2RlX21vZHVsZXMvQG1lbmRhYmxlL2ZpcmVjcmF3bC1qcy9kaXN0L3BhY2thZ2UtU1lLQ001SlQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgcmVxdWlyZV9wYWNrYWdlXG59IGZyb20gXCIuL2NodW5rLUozQkVCWDNZLmpzXCI7XG5leHBvcnQgZGVmYXVsdCByZXF1aXJlX3BhY2thZ2UoKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@mendable/firecrawl-js/dist/package-SYKCM5JT.js\n");

/***/ })

};
;